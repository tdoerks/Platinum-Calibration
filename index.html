<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Pipette Calibration System</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 25px 50px rgba(0,0,0,0.15);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: white;
            padding: 30px;
            text-align: center;
            position: relative;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            opacity: 0.9;
            font-size: 1.1em;
        }

        .nav-tabs {
            display: flex;
            background: #f8f9fa;
            border-bottom: 2px solid #e9ecef;
        }

        .nav-tab {
            flex: 1;
            padding: 15px 20px;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 16px;
            font-weight: 500;
            transition: all 0.3s ease;
            position: relative;
        }

        .nav-tab:hover {
            background: #e9ecef;
        }

        .nav-tab.active {
            background: white;
            color: #007bff;
            border-bottom: 3px solid #007bff;
        }

        .tab-content {
            display: none;
            padding: 30px;
            min-height: 600px;
        }

        .tab-content.active {
            display: block;
        }

        .form-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .form-group {
            display: flex;
            flex-direction: column;
        }

        .form-group label {
            font-weight: 600;
            margin-bottom: 8px;
            color: #333;
        }

        .form-group input, 
        .form-group select, 
        .form-group textarea {
            padding: 12px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s ease;
        }

        .form-group input:focus,
        .form-group select:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: #007bff;
            box-shadow: 0 0 0 3px rgba(0,123,255,0.1);
        }

        .pipette-card {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
            border: 2px solid #e9ecef;
            transition: all 0.3s ease;
        }

        .pipette-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
        }

        .pipette-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #dee2e6;
        }

        .pipette-header h3 {
            color: #2c3e50;
            margin-bottom: 5px;
        }

        .status-badge {
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .status-pass {
            background: #28a745;
            color: #ffffff;
            border: 2px solid #1e7e34;
        }

        .status-pass::before {
            content: '✓ ';
            font-weight: bold;
        }

        .status-fail {
            background: #dc3545;
            color: #ffffff;
            border: 2px solid #bd2130;
        }

        .status-fail::before {
            content: '✗ ';
            font-weight: bold;
        }

        .status-pending {
            background: #ffc107;
            color: #000000;
            border: 2px solid #e0a800;
        }

        .status-pending::before {
            content: '⏳ ';
        }

        .measurement-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: white;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0,0,0,0.08);
        }

        .measurement-table th {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 10px;
            text-align: center;
            font-weight: 600;
        }

        .measurement-table td {
            padding: 12px 10px;
            text-align: center;
            border-bottom: 1px solid #e9ecef;
        }

        .measurement-input {
            width: 80px;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            text-align: center;
        }

        .measurement-input:focus {
            border-color: #007bff;
            box-shadow: 0 0 0 2px rgba(0,123,255,0.25);
        }

        .measurement-input.pass {
            background-color: #e7f5e9;
            border-color: #28a745;
            border-width: 2px;
        }

        .measurement-input.fail {
            background-color: #ffe6e6;
            border-color: #dc3545;
            border-width: 3px;
            font-weight: bold;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-block;
            text-align: center;
            margin: 5px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #007bff 0%, #0056b3 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,123,255,0.3);
        }

        .btn-success {
            background: linear-gradient(135deg, #28a745 0%, #1e7e34 100%);
            color: white;
        }

        .btn-success:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(40,167,69,0.3);
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-danger {
            background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
            color: white;
        }

        .statistics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .stat-card {
            background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            border: 2px solid #e9ecef;
        }

        .stat-value {
            font-size: 2em;
            font-weight: bold;
            color: #007bff;
        }

        .stat-label {
            color: #6c757d;
            margin-top: 5px;
        }

        .alert {
            padding: 15px;
            margin: 15px 0;
            border-radius: 8px;
            font-weight: 500;
        }

        .alert-success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .alert-warning {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeeba;
        }

        .alert-danger {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .alert-info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e9ecef;
            border-radius: 4px;
            overflow: hidden;
            margin: 20px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            transition: width 0.5s ease;
        }

        .environmental-data {
            background: #e3f2fd;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
        }

        @media (max-width: 768px) {
            .container {
                margin: 10px;
                border-radius: 10px;
            }
            
            .header {
                padding: 20px;
            }
            
            .header h1 {
                font-size: 1.8em;
            }
            
            .form-grid {
                grid-template-columns: 1fr;
            }
            
            .measurement-table {
                font-size: 12px;
            }
            
            .measurement-input {
                width: 60px;
            }
        }

        .report-section {
            background: white;
            padding: 30px;
            margin: 20px 0;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        @media print {
            /* Hide UI elements */
            .header,
            .nav-tabs,
            .btn,
            .save-indicator,
            .pipette-card .pipette-header button,
            .tab-content:not(.active) {
                display: none !important;
            }

            /* Clean backgrounds */
            body {
                background: white;
                padding: 0;
                margin: 0;
            }

            .container {
                box-shadow: none;
                border-radius: 0;
                max-width: 100%;
                margin: 0;
                padding: 0;
            }

            /* Page setup */
            @page {
                margin: 0.75in 0.5in;
                size: letter portrait;
            }

            /* Page breaks */
            .pipette-card,
            .report-section,
            h2 {
                page-break-inside: avoid;
                page-break-after: auto;
            }

            /* Optimize tables for print */
            .measurement-table {
                font-size: 9pt;
                border-collapse: collapse;
                width: 100%;
            }

            .measurement-table th {
                background: #f0f0f0 !important;
                color: black !important;
                border: 1px solid #000;
                padding: 6px 4px;
                -webkit-print-color-adjust: exact;
                print-color-adjust: exact;
            }

            .measurement-table td {
                border: 1px solid #666;
                padding: 4px;
            }

            /* Black & white friendly status badges */
            .status-badge {
                border: 2px solid #000 !important;
                background: white !important;
                color: black !important;
                -webkit-print-color-adjust: exact;
                print-color-adjust: exact;
            }

            .status-pass::before {
                content: '✓ ';
                font-weight: bold;
            }

            .status-fail::before {
                content: '✗ ';
                font-weight: bold;
            }

            /* Ensure gradient headers print properly */
            .pipette-card h3,
            table tr[style*="background"] {
                -webkit-print-color-adjust: exact;
                print-color-adjust: exact;
            }

            /* Improve text readability */
            body {
                font-size: 11pt;
                line-height: 1.4;
            }

            h1 { font-size: 18pt; }
            h2 { font-size: 16pt; }
            h3 { font-size: 14pt; }
            h4 { font-size: 12pt; }

            /* Compact spacing for print */
            .form-grid,
            .statistics {
                gap: 10px;
            }

            /* Remove unnecessary padding */
            .tab-content {
                padding: 0 !important;
            }
        }

        .save-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 20px;
            background: #28a745;
            color: white;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .save-indicator.show {
            opacity: 1;
        }

        .session-card {
            background: white;
            padding: 20px;
            margin: 15px 0;
            border-radius: 10px;
            border: 2px solid #e9ecef;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .session-card:hover {
            border-color: #007bff;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .session-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .session-date {
            font-size: 18px;
            font-weight: 600;
            color: #2c3e50;
        }

        .session-stats {
            display: flex;
            gap: 15px;
            margin-top: 10px;
        }

        .session-stat {
            font-size: 14px;
            color: #6c757d;
        }
    </style>
</head>
<body>
    <div id="saveIndicator" class="save-indicator">Saved</div>

    <script>
        // Define ALL functions first to avoid reference errors
        let pipettes = [];
        let currentPipetteId = 0;
        let currentSessionId = null;
        let saveTimeout = null;

        // ISO 8655 Specifications Database - Complete with all models
        const isoSpecs = {
            'P-2': {
                0.2: { accuracy: { from: 0.12, to: 0.28, percent: 40.0, ul: 0.08 }, precision: { percent: 20.0, ul: 0.04 } },
                0.5: { accuracy: { from: 0.42, to: 0.58, percent: 16.0, ul: 0.08 }, precision: { percent: 8.0, ul: 0.04 } },
                1: { accuracy: { from: 0.92, to: 1.08, percent: 8.0, ul: 0.08 }, precision: { percent: 4.0, ul: 0.04 } },
                2: { accuracy: { from: 1.92, to: 2.08, percent: 4.0, ul: 0.08 }, precision: { percent: 2.0, ul: 0.04 } }
            },
            'P-2.5': {
                0.5: { accuracy: { from: 0.42, to: 0.58, percent: 16.0, ul: 0.08 }, precision: { percent: 8.0, ul: 0.04 } },
                1.25: { accuracy: { from: 1.17, to: 1.33, percent: 6.4, ul: 0.08 }, precision: { percent: 3.2, ul: 0.04 } },
                2.5: { accuracy: { from: 2.42, to: 2.58, percent: 3.2, ul: 0.08 }, precision: { percent: 1.6, ul: 0.04 } }
            },
            'P-10': {
                1: { accuracy: { from: 0.88, to: 1.12, percent: 12.0, ul: 0.12 }, precision: { percent: 8.0, ul: 0.08 } },
                2: { accuracy: { from: 1.88, to: 2.12, percent: 6.0, ul: 0.12 }, precision: { percent: 4.0, ul: 0.08 } },
                5: { accuracy: { from: 4.88, to: 5.12, percent: 2.4, ul: 0.12 }, precision: { percent: 1.6, ul: 0.08 } },
                10: { accuracy: { from: 9.88, to: 10.12, percent: 1.2, ul: 0.12 }, precision: { percent: 0.8, ul: 0.08 } }
            },
            'P-20': {
                2: { accuracy: { from: 1.80, to: 2.20, percent: 10.0, ul: 0.2 }, precision: { percent: 5.0, ul: 0.1 } },
                5: { accuracy: { from: 4.80, to: 5.20, percent: 4.0, ul: 0.2 }, precision: { percent: 2.0, ul: 0.1 } },
                10: { accuracy: { from: 9.80, to: 10.20, percent: 2.0, ul: 0.2 }, precision: { percent: 1.0, ul: 0.1 } },
                20: { accuracy: { from: 19.80, to: 20.20, percent: 1.0, ul: 0.2 }, precision: { percent: 0.5, ul: 0.1 } }
            },
            'P-25': {
                5: { accuracy: { from: 4.50, to: 5.50, percent: 10.0, ul: 0.5 }, precision: { percent: 4.0, ul: 0.2 } },
                12.5: { accuracy: { from: 12.00, to: 13.00, percent: 4.0, ul: 0.5 }, precision: { percent: 1.6, ul: 0.2 } },
                25: { accuracy: { from: 24.50, to: 25.50, percent: 2.0, ul: 0.5 }, precision: { percent: 0.8, ul: 0.2 } }
            },
            'P-50': {
                10: { accuracy: { from: 9.50, to: 10.50, percent: 5.0, ul: 0.5 }, precision: { percent: 2.0, ul: 0.2 } },
                25: { accuracy: { from: 24.5, to: 25.5, percent: 2.0, ul: 0.5 }, precision: { percent: 0.8, ul: 0.2 } },
                50: { accuracy: { from: 49.5, to: 50.5, percent: 1.0, ul: 0.5 }, precision: { percent: 0.4, ul: 0.2 } }
            },
            'P-100': {
                10: { accuracy: { from: 9.2, to: 10.8, percent: 8.0, ul: 0.8 }, precision: { percent: 3.0, ul: 0.3 } },
                20: { accuracy: { from: 19.2, to: 20.8, percent: 4.0, ul: 0.8 }, precision: { percent: 1.5, ul: 0.3 } },
                50: { accuracy: { from: 49.2, to: 50.8, percent: 1.6, ul: 0.8 }, precision: { percent: 0.6, ul: 0.3 } },
                100: { accuracy: { from: 99.2, to: 100.8, percent: 0.8, ul: 0.8 }, precision: { percent: 0.3, ul: 0.3 } }
            },
            'P-200': {
                20: { accuracy: { from: 18.4, to: 21.6, percent: 8.0, ul: 1.6 }, precision: { percent: 3.0, ul: 0.6 } },
                50: { accuracy: { from: 48.4, to: 51.6, percent: 3.2, ul: 1.6 }, precision: { percent: 1.2, ul: 0.6 } },
                100: { accuracy: { from: 98.4, to: 101.6, percent: 1.6, ul: 1.6 }, precision: { percent: 0.6, ul: 0.6 } },
                200: { accuracy: { from: 198.4, to: 201.6, percent: 0.8, ul: 1.6 }, precision: { percent: 0.3, ul: 0.6 } }
            },
            'P-250': {
                25: { accuracy: { from: 21.0, to: 29.0, percent: 16.0, ul: 4.0 }, precision: { percent: 6.0, ul: 1.5 } },
                50: { accuracy: { from: 46.0, to: 54.0, percent: 8.0, ul: 4.0 }, precision: { percent: 3.0, ul: 1.5 } },
                125: { accuracy: { from: 121.0, to: 129.0, percent: 3.2, ul: 4.0 }, precision: { percent: 1.2, ul: 1.5 } },
                150: { accuracy: { from: 146.0, to: 154.0, percent: 2.7, ul: 4.0 }, precision: { percent: 1.0, ul: 1.5 } },
                250: { accuracy: { from: 246.0, to: 254.0, percent: 1.6, ul: 4.0 }, precision: { percent: 0.6, ul: 1.5 } }
            },
            'P-300': {
                30: { accuracy: { from: 26.0, to: 34.0, percent: 13.3, ul: 4.0 }, precision: { percent: 5.0, ul: 1.5 } },
                50: { accuracy: { from: 46.0, to: 54.0, percent: 8.0, ul: 4.0 }, precision: { percent: 3.0, ul: 1.5 } },
                200: { accuracy: { from: 196.0, to: 204.0, percent: 2.0, ul: 4.0 }, precision: { percent: 0.8, ul: 1.5 } },
                300: { accuracy: { from: 296.0, to: 304.0, percent: 1.3, ul: 4.0 }, precision: { percent: 0.5, ul: 1.5 } }
            },
            'P-500': {
                100: { accuracy: { from: 96.0, to: 104.0, percent: 4.0, ul: 4.0 }, precision: { percent: 1.5, ul: 1.5 } },
                250: { accuracy: { from: 246.0, to: 254.0, percent: 1.6, ul: 4.0 }, precision: { percent: 0.6, ul: 1.5 } },
                500: { accuracy: { from: 496.0, to: 504.0, percent: 0.8, ul: 4.0 }, precision: { percent: 0.3, ul: 1.5 } }
            },
            'P-1000': {
                100: { accuracy: { from: 92.0, to: 108.0, percent: 8.0, ul: 8.0 }, precision: { percent: 3.0, ul: 3.0 } },
                200: { accuracy: { from: 192.0, to: 208.0, percent: 4.0, ul: 8.0 }, precision: { percent: 1.5, ul: 3.0 } },
                500: { accuracy: { from: 492.0, to: 508.0, percent: 1.6, ul: 8.0 }, precision: { percent: 0.6, ul: 3.0 } },
                1000: { accuracy: { from: 992.0, to: 1008.0, percent: 0.8, ul: 8.0 }, precision: { percent: 0.3, ul: 3.0 } }
            },
            'P-1200': {
                250: { accuracy: { from: 234.0, to: 266.0, percent: 6.4, ul: 16.0 }, precision: { percent: 2.4, ul: 6.0 } },
                600: { accuracy: { from: 584.0, to: 616.0, percent: 2.7, ul: 16.0 }, precision: { percent: 1.0, ul: 6.0 } },
                1200: { accuracy: { from: 1184.0, to: 1216.0, percent: 1.3, ul: 16.0 }, precision: { percent: 0.5, ul: 6.0 } }
            },
            'P-1250': {
                250: { accuracy: { from: 234.0, to: 266.0, percent: 6.4, ul: 16.0 }, precision: { percent: 2.4, ul: 6.0 } },
                625: { accuracy: { from: 609.0, to: 641.0, percent: 2.6, ul: 16.0 }, precision: { percent: 1.0, ul: 6.0 } },
                1250: { accuracy: { from: 1234.0, to: 1266.0, percent: 1.3, ul: 16.0 }, precision: { percent: 0.5, ul: 6.0 } }
            },
            'P-2000': {
                500: { accuracy: { from: 484.0, to: 516.0, percent: 3.2, ul: 16.0 }, precision: { percent: 1.2, ul: 6.0 } },
                1000: { accuracy: { from: 984.0, to: 1016.0, percent: 1.6, ul: 16.0 }, precision: { percent: 0.6, ul: 6.0 } },
                2000: { accuracy: { from: 1984.0, to: 2016.0, percent: 0.8, ul: 16.0 }, precision: { percent: 0.3, ul: 6.0 } }
            },
            'P-5000': {
                1000: { accuracy: { from: 960.0, to: 1040.0, percent: 4.0, ul: 40.0 }, precision: { percent: 1.5, ul: 15.0 } },
                2500: { accuracy: { from: 2460.0, to: 2540.0, percent: 1.6, ul: 40.0 }, precision: { percent: 0.6, ul: 15.0 } },
                5000: { accuracy: { from: 4960.0, to: 5040.0, percent: 0.8, ul: 40.0 }, precision: { percent: 0.3, ul: 15.0 } }
            },
            'P-10000': {
                2000: { accuracy: { from: 1940.0, to: 2060.0, percent: 3.0, ul: 60.0 }, precision: { percent: 1.5, ul: 30.0 } },
                5000: { accuracy: { from: 4940.0, to: 5060.0, percent: 1.2, ul: 60.0 }, precision: { percent: 0.6, ul: 30.0 } },
                10000: { accuracy: { from: 9940.0, to: 10060.0, percent: 0.6, ul: 60.0 }, precision: { percent: 0.3, ul: 30.0 } }
            }
        };

        // ISO 8655 Multi-Channel Pipette Specifications
        const isoSpecsMulti = {
            'P-2': {
                0.2: { accuracy: { from: 0.04, to: 0.36, percent: 80.0, ul: 0.16 }, precision: { percent: 40.0, ul: 0.08 } },
                0.5: { accuracy: { from: 0.34, to: 0.66, percent: 32.0, ul: 0.16 }, precision: { percent: 16.0, ul: 0.08 } },
                1: { accuracy: { from: 0.84, to: 1.16, percent: 16.0, ul: 0.16 }, precision: { percent: 8.0, ul: 0.08 } },
                2: { accuracy: { from: 1.84, to: 2.16, percent: 8.0, ul: 0.16 }, precision: { percent: 4.0, ul: 0.08 } }
            },
            'P-10': {
                1: { accuracy: { from: 0.76, to: 1.24, percent: 24.0, ul: 0.24 }, precision: { percent: 16.0, ul: 0.16 } },
                2: { accuracy: { from: 1.76, to: 2.24, percent: 12.0, ul: 0.24 }, precision: { percent: 8.0, ul: 0.16 } },
                5: { accuracy: { from: 4.76, to: 5.24, percent: 4.8, ul: 0.24 }, precision: { percent: 3.2, ul: 0.16 } },
                10: { accuracy: { from: 9.76, to: 10.24, percent: 2.4, ul: 0.24 }, precision: { percent: 1.6, ul: 0.16 } }
            },
            'P-20': {
                2: { accuracy: { from: 1.60, to: 2.40, percent: 20.0, ul: 0.4 }, precision: { percent: 10.0, ul: 0.2 } },
                5: { accuracy: { from: 4.60, to: 5.40, percent: 8.0, ul: 0.4 }, precision: { percent: 4.0, ul: 0.2 } },
                10: { accuracy: { from: 9.60, to: 10.40, percent: 4.0, ul: 0.4 }, precision: { percent: 2.0, ul: 0.2 } },
                20: { accuracy: { from: 19.60, to: 20.40, percent: 2.0, ul: 0.4 }, precision: { percent: 1.0, ul: 0.2 } }
            },
            'P-25': {
                5: { accuracy: { from: 4.00, to: 6.00, percent: 20.0, ul: 1.0 }, precision: { percent: 8.0, ul: 0.4 } },
                12.5: { accuracy: { from: 11.50, to: 13.50, percent: 8.0, ul: 1.0 }, precision: { percent: 3.2, ul: 0.4 } },
                25: { accuracy: { from: 24.00, to: 26.00, percent: 4.0, ul: 1.0 }, precision: { percent: 1.6, ul: 0.4 } }
            },
            'P-50': {
                5: { accuracy: { from: 4.00, to: 6.00, percent: 20.0, ul: 1.0 }, precision: { percent: 8.0, ul: 0.4 } },
                10: { accuracy: { from: 9.00, to: 11.00, percent: 10.0, ul: 1.0 }, precision: { percent: 4.0, ul: 0.4 } },
                25: { accuracy: { from: 24.0, to: 26.0, percent: 4.0, ul: 1.0 }, precision: { percent: 1.6, ul: 0.4 } },
                50: { accuracy: { from: 49.0, to: 51.0, percent: 2.0, ul: 1.0 }, precision: { percent: 0.8, ul: 0.4 } }
            },
            'P-100': {
                10: { accuracy: { from: 8.4, to: 11.6, percent: 16.0, ul: 1.6 }, precision: { percent: 6.0, ul: 0.6 } },
                20: { accuracy: { from: 18.4, to: 21.6, percent: 8.0, ul: 1.6 }, precision: { percent: 3.0, ul: 0.6 } },
                50: { accuracy: { from: 48.4, to: 51.6, percent: 3.2, ul: 1.6 }, precision: { percent: 1.2, ul: 0.6 } },
                100: { accuracy: { from: 98.4, to: 101.6, percent: 1.6, ul: 1.6 }, precision: { percent: 0.6, ul: 0.6 } }
            },
            'P-200': {
                20: { accuracy: { from: 16.8, to: 23.2, percent: 16.0, ul: 3.2 }, precision: { percent: 6.0, ul: 1.2 } },
                50: { accuracy: { from: 46.8, to: 53.2, percent: 6.4, ul: 3.2 }, precision: { percent: 2.4, ul: 1.2 } },
                100: { accuracy: { from: 96.8, to: 103.2, percent: 3.2, ul: 3.2 }, precision: { percent: 1.2, ul: 1.2 } },
                200: { accuracy: { from: 196.8, to: 203.2, percent: 1.6, ul: 3.2 }, precision: { percent: 0.6, ul: 1.2 } }
            },
            'P-250': {
                25: { accuracy: { from: 17.0, to: 33.0, percent: 32.0, ul: 8.0 }, precision: { percent: 12.0, ul: 3.0 } },
                50: { accuracy: { from: 42.0, to: 58.0, percent: 16.0, ul: 8.0 }, precision: { percent: 6.0, ul: 3.0 } },
                150: { accuracy: { from: 142.0, to: 158.0, percent: 5.3, ul: 8.0 }, precision: { percent: 2.0, ul: 3.0 } },
                250: { accuracy: { from: 242.0, to: 258.0, percent: 3.2, ul: 8.0 }, precision: { percent: 1.2, ul: 3.0 } }
            },
            'P-300': {
                30: { accuracy: { from: 22.0, to: 38.0, percent: 26.7, ul: 8.0 }, precision: { percent: 10.0, ul: 3.0 } },
                50: { accuracy: { from: 42.0, to: 58.0, percent: 16.0, ul: 8.0 }, precision: { percent: 6.0, ul: 3.0 } },
                150: { accuracy: { from: 142.0, to: 158.0, percent: 5.3, ul: 8.0 }, precision: { percent: 2.0, ul: 3.0 } },
                200: { accuracy: { from: 192.0, to: 208.0, percent: 4.0, ul: 8.0 }, precision: { percent: 1.5, ul: 3.0 } },
                300: { accuracy: { from: 292.0, to: 308.0, percent: 2.7, ul: 8.0 }, precision: { percent: 1.0, ul: 3.0 } }
            },
            'P-500': {
                50: { accuracy: { from: 42.0, to: 58.0, percent: 16.0, ul: 8.0 }, precision: { percent: 6.0, ul: 3.0 } },
                100: { accuracy: { from: 92.0, to: 108.0, percent: 8.0, ul: 8.0 }, precision: { percent: 3.0, ul: 3.0 } },
                250: { accuracy: { from: 242.0, to: 258.0, percent: 3.2, ul: 8.0 }, precision: { percent: 1.2, ul: 3.0 } },
                500: { accuracy: { from: 492.0, to: 508.0, percent: 1.6, ul: 8.0 }, precision: { percent: 0.6, ul: 3.0 } }
            },
            'P-1000': {
                100: { accuracy: { from: 84.0, to: 116.0, percent: 16.0, ul: 16.0 }, precision: { percent: 6.0, ul: 6.0 } },
                200: { accuracy: { from: 184.0, to: 216.0, percent: 8.0, ul: 16.0 }, precision: { percent: 3.0, ul: 6.0 } },
                500: { accuracy: { from: 484.0, to: 516.0, percent: 3.2, ul: 16.0 }, precision: { percent: 1.2, ul: 6.0 } },
                1000: { accuracy: { from: 984.0, to: 1016.0, percent: 1.6, ul: 16.0 }, precision: { percent: 0.6, ul: 6.0 } }
            },
            'P-1200': {
                120: { accuracy: { from: 88.0, to: 152.0, percent: 26.7, ul: 32.0 }, precision: { percent: 10.0, ul: 12.0 } },
                250: { accuracy: { from: 218.0, to: 282.0, percent: 12.8, ul: 32.0 }, precision: { percent: 4.8, ul: 12.0 } },
                600: { accuracy: { from: 568.0, to: 632.0, percent: 5.3, ul: 32.0 }, precision: { percent: 2.0, ul: 12.0 } },
                1200: { accuracy: { from: 1168.0, to: 1232.0, percent: 2.7, ul: 32.0 }, precision: { percent: 1.0, ul: 12.0 } }
            },
            'P-1250': {
                125: { accuracy: { from: 93.0, to: 157.0, percent: 25.6, ul: 32.0 }, precision: { percent: 9.6, ul: 12.0 } },
                250: { accuracy: { from: 218.0, to: 282.0, percent: 12.8, ul: 32.0 }, precision: { percent: 4.8, ul: 12.0 } },
                625: { accuracy: { from: 593.0, to: 657.0, percent: 5.1, ul: 32.0 }, precision: { percent: 1.9, ul: 12.0 } },
                1250: { accuracy: { from: 1218.0, to: 1282.0, percent: 2.6, ul: 32.0 }, precision: { percent: 1.0, ul: 12.0 } }
            },
            'P-2000': {
                200: { accuracy: { from: 168.0, to: 232.0, percent: 16.0, ul: 32.0 }, precision: { percent: 6.0, ul: 12.0 } },
                400: { accuracy: { from: 368.0, to: 432.0, percent: 8.0, ul: 32.0 }, precision: { percent: 3.0, ul: 12.0 } },
                1000: { accuracy: { from: 968.0, to: 1032.0, percent: 3.2, ul: 32.0 }, precision: { percent: 1.2, ul: 12.0 } },
                2000: { accuracy: { from: 1968.0, to: 2032.0, percent: 1.6, ul: 32.0 }, precision: { percent: 0.6, ul: 12.0 } }
            },
            'P-5000': {
                500: { accuracy: { from: 420.0, to: 580.0, percent: 16.0, ul: 80.0 }, precision: { percent: 6.0, ul: 30.0 } },
                1000: { accuracy: { from: 920.0, to: 1080.0, percent: 8.0, ul: 80.0 }, precision: { percent: 3.0, ul: 30.0 } },
                2500: { accuracy: { from: 2420.0, to: 2580.0, percent: 3.2, ul: 80.0 }, precision: { percent: 1.2, ul: 30.0 } },
                5000: { accuracy: { from: 4920.0, to: 5080.0, percent: 1.6, ul: 80.0 }, precision: { percent: 0.6, ul: 30.0 } }
            },
            'P-10000': {
                500: { accuracy: { from: 380.0, to: 620.0, percent: 24.0, ul: 120.0 }, precision: { percent: 12.0, ul: 60.0 } },
                2000: { accuracy: { from: 1880.0, to: 2120.0, percent: 6.0, ul: 120.0 }, precision: { percent: 3.0, ul: 60.0 } },
                5000: { accuracy: { from: 4880.0, to: 5120.0, percent: 2.4, ul: 120.0 }, precision: { percent: 1.2, ul: 60.0 } },
                10000: { accuracy: { from: 9880.0, to: 10120.0, percent: 1.6, ul: 120.0 }, precision: { percent: 0.6, ul: 60.0 } }
            }
        };

        function getVolumePrecision(volume) {
            return volume <= 25 ? { step: 0.01, decimals: 2 } : { step: 0.1, decimals: 1 };
        }

        function formatVolume(value, decimals) {
            // Auto-determine decimal places based on volume if not specified
            if (decimals === undefined) {
                const precision = getVolumePrecision(parseFloat(value));
                decimals = precision.decimals;
            }
            return parseFloat(value).toFixed(decimals);
        }

        // ========== LocalStorage Persistence Functions ==========

        function generateSessionId() {
            return 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        }

        function autoSave() {
            if (!currentSessionId) {
                currentSessionId = generateSessionId();
            }

            const sessionData = {
                id: currentSessionId,
                sessionInfo: getSessionInfo(),
                pipettes: pipettes,
                currentPipetteId: currentPipetteId,
                timestamp: new Date().toISOString(),
                lastModified: new Date().toISOString()
            };

            // Save current session
            localStorage.setItem('currentSession', JSON.stringify(sessionData));

            // Update sessions list
            let sessions = JSON.parse(localStorage.getItem('calibrationSessions') || '[]');
            const existingIndex = sessions.findIndex(s => s.id === currentSessionId);

            if (existingIndex >= 0) {
                sessions[existingIndex] = sessionData;
            } else {
                sessions.unshift(sessionData);
            }

            // Keep only last 50 sessions
            if (sessions.length > 50) {
                sessions = sessions.slice(0, 50);
            }

            localStorage.setItem('calibrationSessions', JSON.stringify(sessions));

            showSaveIndicator();
        }

        function debouncedAutoSave() {
            clearTimeout(saveTimeout);
            saveTimeout = setTimeout(() => {
                autoSave();
            }, 500); // Save 500ms after last change
        }

        function showSaveIndicator() {
            const indicator = document.getElementById('saveIndicator');
            indicator.classList.add('show');
            setTimeout(() => {
                indicator.classList.remove('show');
            }, 2000);
        }

        function loadCurrentSession() {
            const savedSession = localStorage.getItem('currentSession');
            if (!savedSession) return false;

            try {
                const sessionData = JSON.parse(savedSession);
                currentSessionId = sessionData.id;
                pipettes = sessionData.pipettes || [];
                currentPipetteId = sessionData.currentPipetteId || 0;

                // Restore session info
                const sessionInfo = sessionData.sessionInfo || {};
                Object.keys(sessionInfo).forEach(key => {
                    const element = document.getElementById(key);
                    if (element) {
                        element.value = sessionInfo[key] || '';
                    }
                });

                // Render all pipettes (add backward compatibility for old sessions)
                pipettes.forEach(pipette => {
                    // Add default channelType for old sessions
                    if (!pipette.channelType) {
                        pipette.channelType = 'single';
                        pipette.channelCount = 1;
                    }
                    renderPipette(pipette);
                    ['asFound', 'asLeft'].forEach(condition => {
                        ['low', 'mid', 'high'].forEach(point => {
                            validateMeasurement(pipette.id, condition, point);
                        });
                    });
                    updateOverallStatus(pipette.id);
                });

                updateProgress();
                updateAnalysis();
                return true;
            } catch (e) {
                console.error('Error loading session:', e);
                return false;
            }
        }

        function newSession() {
            if (pipettes.length > 0) {
                if (!confirm('Start a new session? Current data will be saved to history.')) {
                    return;
                }
                autoSave(); // Save current before starting new
            }

            // Clear current session
            currentSessionId = null;
            pipettes = [];
            currentPipetteId = 0;
            document.getElementById('pipettesContainer').innerHTML = '';

            // Clear session form
            document.querySelectorAll('#session input, #session select').forEach(input => {
                if (input.type === 'date') {
                    // Keep default dates
                } else {
                    input.value = '';
                }
            });

            localStorage.removeItem('currentSession');
            updateProgress();
            updateAnalysis();

            alert('New session started!');
        }

        function loadSessionFromHistory(sessionId) {
            const sessions = JSON.parse(localStorage.getItem('calibrationSessions') || '[]');
            const session = sessions.find(s => s.id === sessionId);

            if (!session) {
                alert('Session not found!');
                return;
            }

            if (confirm('Load this session? Current work will be saved.')) {
                if (currentSessionId) {
                    autoSave();
                }

                // Clear current
                document.getElementById('pipettesContainer').innerHTML = '';
                pipettes = [];

                // Load selected session
                currentSessionId = session.id;
                pipettes = session.pipettes || [];
                currentPipetteId = session.currentPipetteId || 0;

                // Restore session info
                const sessionInfo = session.sessionInfo || {};
                Object.keys(sessionInfo).forEach(key => {
                    const element = document.getElementById(key);
                    if (element) {
                        element.value = sessionInfo[key] || '';
                    }
                });

                // Render pipettes
                pipettes.forEach(pipette => {
                    renderPipette(pipette);
                    ['asFound', 'asLeft'].forEach(condition => {
                        ['low', 'mid', 'high'].forEach(point => {
                            validateMeasurement(pipette.id, condition, point);
                        });
                    });
                    updateOverallStatus(pipette.id);
                });

                updateProgress();
                updateAnalysis();

                // Save as current session
                localStorage.setItem('currentSession', JSON.stringify(session));

                showTab('calibration', document.querySelector('.nav-tab:nth-child(2)'));
            }
        }

        function deleteSession(sessionId, event) {
            event.stopPropagation();

            if (!confirm('Delete this session? This cannot be undone.')) {
                return;
            }

            let sessions = JSON.parse(localStorage.getItem('calibrationSessions') || '[]');
            sessions = sessions.filter(s => s.id !== sessionId);
            localStorage.setItem('calibrationSessions', JSON.stringify(sessions));

            if (currentSessionId === sessionId) {
                localStorage.removeItem('currentSession');
                currentSessionId = null;
            }

            loadHistory();
        }

        function importFromFile() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const sessionData = JSON.parse(event.target.result);

                        if (confirm('Load this session from file? Current work will be saved.')) {
                            if (currentSessionId) {
                                autoSave();
                            }

                            // Assign new session ID
                            sessionData.id = generateSessionId();
                            sessionData.lastModified = new Date().toISOString();

                            // Clear and load
                            document.getElementById('pipettesContainer').innerHTML = '';
                            pipettes = sessionData.pipettes || [];
                            currentPipetteId = sessionData.currentPipetteId || (pipettes.length > 0 ? Math.max(...pipettes.map(p => p.id)) : 0);
                            currentSessionId = sessionData.id;

                            // Restore session info
                            const sessionInfo = sessionData.sessionInfo || {};
                            Object.keys(sessionInfo).forEach(key => {
                                const element = document.getElementById(key);
                                if (element) {
                                    element.value = sessionInfo[key] || '';
                                }
                            });

                            // Render pipettes
                            pipettes.forEach(pipette => {
                                renderPipette(pipette);
                                ['asFound', 'asLeft'].forEach(condition => {
                                    ['low', 'mid', 'high'].forEach(point => {
                                        validateMeasurement(pipette.id, condition, point);
                                    });
                                });
                                updateOverallStatus(pipette.id);
                            });

                            updateProgress();
                            updateAnalysis();
                            autoSave();

                            alert('Session imported successfully!');
                        }
                    } catch (error) {
                        alert('Error importing file: ' + error.message);
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        }

        // ========== End LocalStorage Functions ==========

        function showTab(tabName, clickedTab) {
            const tabs = document.querySelectorAll('.tab-content');
            tabs.forEach(tab => tab.classList.remove('active'));
            
            const navTabs = document.querySelectorAll('.nav-tab');
            navTabs.forEach(tab => tab.classList.remove('active'));
            
            document.getElementById(tabName).classList.add('active');
            if (clickedTab) {
                clickedTab.classList.add('active');
            }

            if (tabName === 'analysis') {
                updateAnalysis();
            }
        }

        function addPipette() {
            currentPipetteId++;
            const pipette = {
                id: currentPipetteId,
                number: '',
                brand: 'Eppendorf',
                pipetteModel: '',  // New field for actual model like "Research Plus", "LTS", etc.
                serial: '',
                volume: 100,
                model: 'P-100',      // Keep this for ISO validation (volume range)
                testVolume: 100,
                channelType: 'single',  // 'single', 'multi-8ch', or 'multi-12ch'
                channelCount: 1,        // 1, 8, or 12
                measurements: {
                    asFound: { low: ['', '', '', ''], mid: ['', '', '', ''], high: ['', '', '', ''] },
                    asLeft: { low: ['', '', '', ''], mid: ['', '', '', ''], high: ['', '', '', ''] }
                },
                comments: '',
                status: 'pending',         // Overall status for compatibility
                statusAsFound: 'pending',  // As Found pass/fail status
                statusAsLeft: 'pending'    // As Left pass/fail status
            };

            pipettes.push(pipette);
            renderPipette(pipette);
            updateProgress();
            debouncedAutoSave();
        }

        // Generate measurement table HTML based on channel type
        function generateMeasurementTable(pipette, precision) {
            if (pipette.channelType === 'single') {
                return generateSingleChannelTable(pipette, precision);
            } else {
                return generateMultiChannelTable(pipette, precision);
            }
        }

        // Single channel table (4 readings per test point)
        function generateSingleChannelTable(pipette, precision) {
            return `
                <table class="measurement-table">
                    <thead>
                        <tr>
                            <th rowspan="2">Test Point</th>
                            <th colspan="4">As Found</th>
                            <th rowspan="2">As Found<br>Pass/Fail</th>
                            <th colspan="4">As Left</th>
                            <th rowspan="2">As Left<br>Pass/Fail</th>
                        </tr>
                        <tr>
                            <th>Reading 1</th>
                            <th>Reading 2</th>
                            <th>Reading 3</th>
                            <th>Reading 4</th>
                            <th>Reading 1</th>
                            <th>Reading 2</th>
                            <th>Reading 3</th>
                            <th>Reading 4</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Low (${formatVolume(getNominalVolume('low', pipette.model))} μL)</strong></td>
                            ${[0,1,2,3].map(i => `<td><input type="number" step="${precision.step}" class="measurement-input" onchange="updateMeasurement(${pipette.id}, 'asFound', 'low', ${i}, this.value)" value="${pipette.measurements.asFound.low[i] || ''}" placeholder="${precision.decimals === 2 ? '0.00' : '0.0'}"></td>`).join('')}
                            <td><span id="status-asFound-low-${pipette.id}" class="status-badge status-pending">PENDING</span></td>
                            ${[0,1,2,3].map(i => `<td><input type="number" step="${precision.step}" class="measurement-input" onchange="updateMeasurement(${pipette.id}, 'asLeft', 'low', ${i}, this.value)" value="${pipette.measurements.asLeft.low[i] || ''}" placeholder="${precision.decimals === 2 ? '0.00' : '0.0'}"></td>`).join('')}
                            <td><span id="status-asLeft-low-${pipette.id}" class="status-badge status-pending">PENDING</span></td>
                        </tr>
                        <tr>
                            <td><strong>Mid (${formatVolume(getNominalVolume('mid', pipette.model))} μL)</strong></td>
                            ${[0,1,2,3].map(i => `<td><input type="number" step="${precision.step}" class="measurement-input" onchange="updateMeasurement(${pipette.id}, 'asFound', 'mid', ${i}, this.value)" value="${pipette.measurements.asFound.mid[i] || ''}" placeholder="${precision.decimals === 2 ? '0.00' : '0.0'}"></td>`).join('')}
                            <td><span id="status-asFound-mid-${pipette.id}" class="status-badge status-pending">PENDING</span></td>
                            ${[0,1,2,3].map(i => `<td><input type="number" step="${precision.step}" class="measurement-input" onchange="updateMeasurement(${pipette.id}, 'asLeft', 'mid', ${i}, this.value)" value="${pipette.measurements.asLeft.mid[i] || ''}" placeholder="${precision.decimals === 2 ? '0.00' : '0.0'}"></td>`).join('')}
                            <td><span id="status-asLeft-mid-${pipette.id}" class="status-badge status-pending">PENDING</span></td>
                        </tr>
                        <tr>
                            <td><strong>High (${formatVolume(getNominalVolume('high', pipette.model))} μL)</strong></td>
                            ${[0,1,2,3].map(i => `<td><input type="number" step="${precision.step}" class="measurement-input" onchange="updateMeasurement(${pipette.id}, 'asFound', 'high', ${i}, this.value)" value="${pipette.measurements.asFound.high[i] || ''}" placeholder="${precision.decimals === 2 ? '0.00' : '0.0'}"></td>`).join('')}
                            <td><span id="status-asFound-high-${pipette.id}" class="status-badge status-pending">PENDING</span></td>
                            ${[0,1,2,3].map(i => `<td><input type="number" step="${precision.step}" class="measurement-input" onchange="updateMeasurement(${pipette.id}, 'asLeft', 'high', ${i}, this.value)" value="${pipette.measurements.asLeft.high[i] || ''}" placeholder="${precision.decimals === 2 ? '0.00' : '0.0'}"></td>`).join('')}
                            <td><span id="status-asLeft-high-${pipette.id}" class="status-badge status-pending">PENDING</span></td>
                        </tr>
                    </tbody>
                </table>
            `;
        }

        // Multi-channel table (one reading per channel per test point)
        function generateMultiChannelTable(pipette, precision) {
            const channelCount = pipette.channelCount;
            const testPoints = [
                { name: 'Low', key: 'low', volume: getNominalVolume('low', pipette.model) },
                { name: 'Mid', key: 'mid', volume: getNominalVolume('mid', pipette.model) },
                { name: 'High', key: 'high', volume: getNominalVolume('high', pipette.model) }
            ];

            // Generate rows for each channel
            let rows = '';
            for (let ch = 0; ch < channelCount; ch++) {
                rows += `
                    <tr>
                        <td><strong>Channel ${ch + 1}</strong></td>
                        ${testPoints.map(point => {
                            const pointPrecision = getVolumePrecision(point.volume);
                            return `
                            <td><input type="number" step="${pointPrecision.step}" class="measurement-input"
                                onchange="updateMeasurement(${pipette.id}, 'asFound', '${point.key}', ${ch}, this.value)"
                                value="${pipette.measurements.asFound[point.key][ch] || ''}"
                                placeholder="${pointPrecision.decimals === 2 ? '0.00' : '0.0'}">
                            </td>
                        `}).join('')}
                        ${testPoints.map(point => {
                            const pointPrecision = getVolumePrecision(point.volume);
                            return `
                            <td><input type="number" step="${pointPrecision.step}" class="measurement-input"
                                onchange="updateMeasurement(${pipette.id}, 'asLeft', '${point.key}', ${ch}, this.value)"
                                value="${pipette.measurements.asLeft[point.key][ch] || ''}"
                                placeholder="${pointPrecision.decimals === 2 ? '0.00' : '0.0'}">
                            </td>
                        `}).join('')}
                    </tr>
                `;
            }

            // Add status row at the bottom (one status per test point)
            rows += `
                <tr style="background: #f0f0f0; font-weight: bold;">
                    <td>Status</td>
                    <td colspan="3" style="text-align: center;">
                        <span id="status-asFound-low-${pipette.id}" class="status-badge status-pending">LOW</span>
                        <span id="status-asFound-mid-${pipette.id}" class="status-badge status-pending">MID</span>
                        <span id="status-asFound-high-${pipette.id}" class="status-badge status-pending">HIGH</span>
                    </td>
                    <td colspan="3" style="text-align: center;">
                        <span id="status-asLeft-low-${pipette.id}" class="status-badge status-pending">LOW</span>
                        <span id="status-asLeft-mid-${pipette.id}" class="status-badge status-pending">MID</span>
                        <span id="status-asLeft-high-${pipette.id}" class="status-badge status-pending">HIGH</span>
                    </td>
                </tr>
            `;

            return `
                <table class="measurement-table">
                    <thead>
                        <tr>
                            <th rowspan="2">Channel</th>
                            <th colspan="3">As Found</th>
                            <th colspan="3">As Left</th>
                        </tr>
                        <tr>
                            <th>Low (${formatVolume(testPoints[0].volume)} μL)</th>
                            <th>Mid (${formatVolume(testPoints[1].volume)} μL)</th>
                            <th>High (${formatVolume(testPoints[2].volume)} μL)</th>
                            <th>Low (${formatVolume(testPoints[0].volume)} μL)</th>
                            <th>Mid (${formatVolume(testPoints[1].volume)} μL)</th>
                            <th>High (${formatVolume(testPoints[2].volume)} μL)</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${rows}
                    </tbody>
                </table>
            `;
        }

        function renderPipette(pipette) {
            const container = document.getElementById('pipettesContainer');
            const pipetteDiv = document.createElement('div');
            pipetteDiv.className = 'pipette-card';
            pipetteDiv.id = `pipette-${pipette.id}`;

            const volumeRanges = getVolumeRanges(pipette.model);
            const precision = getVolumePrecision(pipette.testVolume);
            
            pipetteDiv.innerHTML = `
                <div class="pipette-header">
                    <div>
                        <h3>Pipette ${pipette.id}</h3>
                        <span class="status-badge status-${pipette.status}" id="status-${pipette.id}">
                            ${pipette.status.toUpperCase()}
                        </span>
                    </div>
                    <button class="btn btn-danger" onclick="removePipette(${pipette.id})">🗑️ Remove</button>
                </div>

                <div class="form-grid">
                    <div class="form-group">
                        <label>Pipette Number</label>
                        <input type="text" value="${pipette.number}" onchange="updatePipetteInfo(${pipette.id}, 'number', this.value)">
                    </div>
                    <div class="form-group">
                        <label>Brand</label>
                        <input type="text" value="${pipette.brand}" onchange="updatePipetteInfo(${pipette.id}, 'brand', this.value)">
                    </div>
                    <div class="form-group">
                        <label>Channel Type</label>
                        <select onchange="updateChannelType(${pipette.id}, this.value)">
                            <option value="single" ${pipette.channelType === 'single' ? 'selected' : ''}>Single Channel</option>
                            <option value="multi-8ch" ${pipette.channelType === 'multi-8ch' ? 'selected' : ''}>Multi-Channel (8ch)</option>
                            <option value="multi-12ch" ${pipette.channelType === 'multi-12ch' ? 'selected' : ''}>Multi-Channel (12ch)</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Model</label>
                        <input type="text" value="${pipette.pipetteModel || ''}" onchange="updatePipetteInfo(${pipette.id}, 'pipetteModel', this.value)">
                    </div>
                    <div class="form-group">
                        <label>Serial Number</label>
                        <input type="text" value="${pipette.serial}" onchange="updatePipetteInfo(${pipette.id}, 'serial', this.value)">
                    </div>
                    <div class="form-group">
                        <label>Volume</label>
                        <select onchange="updatePipetteModel(${pipette.id}, this.value)">
                            <option value="P-2" ${pipette.model === 'P-2' ? 'selected' : ''}>P-2 (0.2-2 μL)</option>
                            <option value="P-2.5" ${pipette.model === 'P-2.5' ? 'selected' : ''}>P-2.5 (0.5-2.5 μL)</option>
                            <option value="P-10" ${pipette.model === 'P-10' ? 'selected' : ''}>P-10 (1-10 μL)</option>
                            <option value="P-20" ${pipette.model === 'P-20' ? 'selected' : ''}>P-20 (2-20 μL)</option>
                            <option value="P-25" ${pipette.model === 'P-25' ? 'selected' : ''}>P-25 (5-25 μL)</option>
                            <option value="P-50" ${pipette.model === 'P-50' ? 'selected' : ''}>P-50 (10-50 μL)</option>
                            <option value="P-100" ${pipette.model === 'P-100' ? 'selected' : ''}>P-100 (10-100 μL)</option>
                            <option value="P-200" ${pipette.model === 'P-200' ? 'selected' : ''}>P-200 (20-200 μL)</option>
                            <option value="P-250" ${pipette.model === 'P-250' ? 'selected' : ''}>P-250 (25-250 μL)</option>
                            <option value="P-300" ${pipette.model === 'P-300' ? 'selected' : ''}>P-300 (30-300 μL)</option>
                            <option value="P-500" ${pipette.model === 'P-500' ? 'selected' : ''}>P-500 (100-500 μL)</option>
                            <option value="P-1000" ${pipette.model === 'P-1000' ? 'selected' : ''}>P-1000 (100-1000 μL)</option>
                            <option value="P-1200" ${pipette.model === 'P-1200' ? 'selected' : ''}>P-1200 (250-1200 μL)</option>
                            <option value="P-1250" ${pipette.model === 'P-1250' ? 'selected' : ''}>P-1250 (250-1250 μL)</option>
                            <option value="P-2000" ${pipette.model === 'P-2000' ? 'selected' : ''}>P-2000 (500-2000 μL)</option>
                            <option value="P-5000" ${pipette.model === 'P-5000' ? 'selected' : ''}>P-5000 (1000-5000 μL)</option>
                            <option value="P-10000" ${pipette.model === 'P-10000' ? 'selected' : ''}>P-10000 (2000-10000 μL)</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Comments</label>
                        <textarea rows="2" onchange="updatePipetteInfo(${pipette.id}, 'comments', this.value)">${pipette.comments}</textarea>
                    </div>
                </div>

                ${generateMeasurementTable(pipette, precision)}

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-top: 15px;">
                    <div>
                        <h4 style="margin: 0 0 10px 0; color: #2c5282;">As Found Results</h4>
                        <div id="calculations-asFound-${pipette.id}">
                            <!-- As Found calculations will appear here -->
                        </div>
                    </div>
                    <div>
                        <h4 style="margin: 0 0 10px 0; color: #2c5282;">As Left Results</h4>
                        <div id="calculations-asLeft-${pipette.id}">
                            <!-- As Left calculations will appear here -->
                        </div>
                    </div>
                </div>
            `;

            container.appendChild(pipetteDiv);
        }

        function getVolumeRanges(model) {
            const ranges = {
                'P-2': [0.2, 0.5, 1, 2],
                'P-2.5': [0.5, 1.25, 2.5],
                'P-10': [1, 2, 5, 10],
                'P-20': [2, 5, 10, 20],
                'P-25': [5, 12.5, 25],
                'P-50': [10, 25, 50],
                'P-100': [10, 20, 50, 100],
                'P-200': [20, 50, 100, 200],
                'P-250': [25, 50, 125, 150, 250],
                'P-300': [30, 50, 200, 300],
                'P-500': [100, 250, 500],
                'P-1000': [100, 200, 500, 1000],
                'P-1200': [250, 600, 1200],
                'P-1250': [250, 625, 1250],
                'P-2000': [500, 1000, 2000],
                'P-5000': [1000, 2500, 5000],
                'P-10000': [2000, 5000, 10000]
            };
            return ranges[model] || [100];
        }

        function updatePipetteModel(pipetteId, newModel) {
            const pipette = pipettes.find(p => p.id === pipetteId);
            if (pipette) {
                pipette.model = newModel;
                const ranges = getVolumeRanges(newModel);
                pipette.volume = ranges[ranges.length - 1];
                pipette.testVolume = pipette.volume;

                document.getElementById(`pipette-${pipetteId}`).remove();
                renderPipette(pipette);
            }
        }

        function updateChannelType(pipetteId, newChannelType) {
            const pipette = pipettes.find(p => p.id === pipetteId);
            if (pipette) {
                pipette.channelType = newChannelType;

                // Update channel count based on type
                if (newChannelType === 'single') {
                    pipette.channelCount = 1;
                    // Reset to 4-reading format for single channel
                    pipette.measurements = {
                        asFound: { low: ['', '', '', ''], mid: ['', '', '', ''], high: ['', '', '', ''] },
                        asLeft: { low: ['', '', '', ''], mid: ['', '', '', ''], high: ['', '', '', ''] }
                    };
                } else if (newChannelType === 'multi-8ch') {
                    pipette.channelCount = 8;
                    // Create 8-channel format (one reading per channel per test point)
                    pipette.measurements = {
                        asFound: { low: ['', '', '', '', '', '', '', ''], mid: ['', '', '', '', '', '', '', ''], high: ['', '', '', '', '', '', '', ''] },
                        asLeft: { low: ['', '', '', '', '', '', '', ''], mid: ['', '', '', '', '', '', '', ''], high: ['', '', '', '', '', '', '', ''] }
                    };
                } else if (newChannelType === 'multi-12ch') {
                    pipette.channelCount = 12;
                    // Create 12-channel format (one reading per channel per test point)
                    pipette.measurements = {
                        asFound: { low: ['', '', '', '', '', '', '', '', '', '', '', ''], mid: ['', '', '', '', '', '', '', '', '', '', '', ''], high: ['', '', '', '', '', '', '', '', '', '', '', ''] },
                        asLeft: { low: ['', '', '', '', '', '', '', '', '', '', '', ''], mid: ['', '', '', '', '', '', '', '', '', '', '', ''], high: ['', '', '', '', '', '', '', '', '', '', '', ''] }
                    };
                }

                // Re-render the pipette card with new layout
                document.getElementById(`pipette-${pipetteId}`).remove();
                renderPipette(pipette);
                debouncedAutoSave();
            }
        }

        function updatePipetteInfo(pipetteId, field, value) {
            const pipette = pipettes.find(p => p.id === pipetteId);
            if (pipette) {
                pipette[field] = value;
                if (field === 'volume') {
                    pipette.testVolume = value;
                    // Re-render to update test points when volume changes
                    document.getElementById(`pipette-${pipetteId}`).remove();
                    renderPipette(pipette);
                }
                debouncedAutoSave();
            }
        }

        function updateMeasurement(pipetteId, condition, point, reading, value) {
            const pipette = pipettes.find(p => p.id === pipetteId);
            if (pipette) {
                if (!pipette.measurements[condition][point]) {
                    pipette.measurements[condition][point] = ['', '', '', ''];
                }
                pipette.measurements[condition][point][reading] = parseFloat(value) || '';

                validateMeasurement(pipetteId, condition, point);
                updateOverallStatus(pipetteId);
                updateProgress();
                debouncedAutoSave();
            }
        }

        function validateMeasurement(pipetteId, condition, point) {
            const pipette = pipettes.find(p => p.id === pipetteId);
            if (!pipette) return;

            if (pipette.channelType === 'single') {
                validateSingleChannel(pipetteId, condition, point);
            } else {
                validateMultiChannel(pipetteId, condition, point);
            }
        }

        function validateSingleChannel(pipetteId, condition, point) {
            const pipette = pipettes.find(p => p.id === pipetteId);
            if (!pipette) return;

            const measurements = pipette.measurements[condition][point];
            if (measurements.filter(m => m !== '').length < 4) return;

            const nominalVolume = getNominalVolume(point, pipette.model);
            const specs = getSpecifications(pipette.model, nominalVolume, false);

            if (!specs) return;

            const mean = measurements.reduce((a, b) => a + b, 0) / 4;
            const cv = calculateCV(measurements);
            const sd = calculateSD(measurements);

            const accuracyPass = measurements.every(reading =>
                reading >= specs.accuracy.from && reading <= specs.accuracy.to
            );

            // ISO 8655: Precision passes if EITHER CV% OR SD meets limit
            const cvPass = cv <= specs.precision.percent;
            const sdPass = sd <= specs.precision.ul;
            const precisionPass = cvPass || sdPass;

            const overallPass = accuracyPass && precisionPass;

            // Update the appropriate status badge based on condition (asFound or asLeft)
            const statusElement = document.getElementById(`status-${condition}-${point}-${pipetteId}`);
            if (statusElement) {
                statusElement.className = `status-badge status-${overallPass ? 'pass' : 'fail'}`;
                statusElement.textContent = overallPass ? 'PASS' : 'FAIL';
            }

            measurements.forEach((_, index) => {
                const input = document.querySelector(`#pipette-${pipetteId} input[onchange*="${condition}"][onchange*="${point}"][onchange*="${index}"]`);
                if (input) {
                    input.className = `measurement-input ${overallPass ? 'pass' : 'fail'}`;
                }
            });

            updateCalculationsDisplay(pipetteId, condition, point, {
                nominal: nominalVolume,
                mean: mean,
                cv: cv,
                sd: sd,
                specs: specs,
                accuracyPass: accuracyPass,
                precisionPass: precisionPass,
                cvPass: cvPass,
                sdPass: sdPass,
                measurements: measurements
            });
        }

        function validateMultiChannel(pipetteId, condition, point) {
            const pipette = pipettes.find(p => p.id === pipetteId);
            if (!pipette) return;

            // For multi-channel, we validate each test point across ALL channels
            // Each test point has ONE measurement per channel (e.g., 8 readings for LOW)
            const testPoints = ['low', 'mid', 'high'];

            // Validate each test point independently
            testPoints.forEach(testPoint => {
                // Collect all channel measurements for this test point
                const measurements = [];
                for (let ch = 0; ch < pipette.channelCount; ch++) {
                    const val = pipette.measurements[condition][testPoint][ch];
                    if (val !== '' && val !== null && val !== undefined) {
                        measurements.push(parseFloat(val));
                    }
                }

                // Need all channels to have data for this test point
                if (measurements.length < pipette.channelCount) return;

                // Get nominal volume and specs for this test point
                const nominalVolume = getNominalVolume(testPoint, pipette.model);
                const specs = getSpecifications(pipette.model, nominalVolume, true);

                if (!specs) return;

                // Calculate statistics across all channels
                const mean = measurements.reduce((a, b) => a + b, 0) / measurements.length;
                const cv = calculateCV(measurements);
                const sd = calculateSD(measurements);

                // Check accuracy: all readings must be within range
                const accuracyPass = measurements.every(reading =>
                    reading >= specs.accuracy.from && reading <= specs.accuracy.to
                );

                // ISO 8655: Precision passes if EITHER CV% OR SD meets limit
                const cvPass = cv <= specs.precision.percent;
                const sdPass = sd <= specs.precision.ul;
                const precisionPass = cvPass || sdPass;

                const overallPass = accuracyPass && precisionPass;

                // Update status badge for this test point
                const statusElement = document.getElementById(`status-${condition}-${testPoint}-${pipetteId}`);
                if (statusElement) {
                    statusElement.className = `status-badge status-${overallPass ? 'pass' : 'fail'}`;
                    statusElement.textContent = overallPass ? 'PASS' : 'FAIL';
                }

                // Update input styling for all channels in this test point
                for (let ch = 0; ch < pipette.channelCount; ch++) {
                    const input = document.querySelector(`#pipette-${pipetteId} input[onchange*="${condition}"][onchange*="${testPoint}"][onchange*="${ch}"]`);
                    if (input) {
                        input.className = `measurement-input ${overallPass ? 'pass' : 'fail'}`;
                    }
                }

                // Display calculation results
                updateCalculationsDisplay(pipetteId, condition, testPoint, {
                    nominal: nominalVolume,
                    mean: mean,
                    cv: cv,
                    sd: sd,
                    specs: specs,
                    accuracyPass: accuracyPass,
                    precisionPass: precisionPass,
                    cvPass: cvPass,
                    sdPass: sdPass,
                    measurements: measurements
                });
            });
        }

        function getNominalVolume(point, model) {
            // Define actual test volumes for each pipette model
            const testVolumes = {
                'P-2': { low: 0.5, mid: 1, high: 2 },
                'P-2.5': { low: 0.5, mid: 1.25, high: 2.5 },
                'P-10': { low: 2, mid: 5, high: 10 },
                'P-20': { low: 5, mid: 10, high: 20 },
                'P-25': { low: 5, mid: 12.5, high: 25 },
                'P-50': { low: 10, mid: 25, high: 50 },
                'P-100': { low: 20, mid: 50, high: 100 },
                'P-200': { low: 50, mid: 100, high: 200 },
                'P-250': { low: 50, mid: 125, high: 250 },
                'P-300': { low: 50, mid: 200, high: 300 },
                'P-500': { low: 100, mid: 250, high: 500 },
                'P-1000': { low: 200, mid: 500, high: 1000 },
                'P-1200': { low: 250, mid: 600, high: 1200 },
                'P-1250': { low: 250, mid: 625, high: 1250 },
                'P-2000': { low: 500, mid: 1000, high: 2000 },
                'P-5000': { low: 1000, mid: 2500, high: 5000 },
                'P-10000': { low: 2000, mid: 5000, high: 10000 }
            };

            return testVolumes[model][point];
        }

        function getSpecifications(model, volume, isMultiChannel = false) {
            const specsDatabase = isMultiChannel ? isoSpecsMulti : isoSpecs;
            const modelSpecs = specsDatabase[model];
            if (!modelSpecs) return null;

            const volumes = Object.keys(modelSpecs).map(v => parseFloat(v));
            const closest = volumes.reduce((prev, curr) =>
                Math.abs(curr - volume) < Math.abs(prev - volume) ? curr : prev
            );

            return modelSpecs[closest];
        }

        function calculateCV(values) {
            const mean = values.reduce((a, b) => a + b, 0) / values.length;
            const variance = values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / values.length;
            const stdDev = Math.sqrt(variance);
            return (stdDev / mean) * 100;
        }

        function calculateSD(values) {
            const mean = values.reduce((a, b) => a + b, 0) / values.length;
            const variance = values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / values.length;
            const stdDev = Math.sqrt(variance);
            return stdDev;
        }

        function updateCalculationsDisplay(pipetteId, condition, point, data) {
            const container = document.getElementById(`calculations-${condition}-${pipetteId}`);
            if (!container) return;

            let calculationsDiv = container.querySelector(`.calculations-${point}`);

            if (!calculationsDiv) {
                calculationsDiv = document.createElement('div');
                calculationsDiv.className = `calculations-${point}`;
                calculationsDiv.style.cssText = 'background: #f8f9fa; padding: 10px; margin: 5px 0; border-radius: 5px; font-size: 12px;';
                container.appendChild(calculationsDiv);
            }

            const precision = getVolumePrecision(data.nominal);
            const readings = data.measurements.map(val => formatVolume(val)).join(', ');

            calculationsDiv.innerHTML = `
                <strong>${point.toUpperCase()} (${formatVolume(data.nominal)} μL):</strong><br>
                Readings: ${readings} μL | Mean: ${formatVolume(data.mean)} μL<br>
                <strong>Accuracy:</strong> Range ${formatVolume(data.specs.accuracy.from)}-${formatVolume(data.specs.accuracy.to)} μL
                <span style="color: ${data.accuracyPass ? 'green' : 'red'}; font-weight: bold;"> ${data.accuracyPass ? '✓ PASS' : '✗ FAIL'}</span><br>
                <strong>Precision (ISO 8655 - pass if EITHER criterion met):</strong><br>
                &nbsp;&nbsp;• CV: ${data.cv.toFixed(2)}% (Limit: ≤${data.specs.precision.percent}%)
                <span style="color: ${data.cvPass ? 'green' : 'red'}; font-weight: bold;"> ${data.cvPass ? '✓' : '✗'}</span><br>
                &nbsp;&nbsp;• SD: ${formatVolume(data.sd)} μL (Limit: ≤${data.specs.precision.ul} μL)
                <span style="color: ${data.sdPass ? 'green' : 'red'}; font-weight: bold;"> ${data.sdPass ? '✓' : '✗'}</span><br>
                &nbsp;&nbsp;<strong>Overall Precision: <span style="color: ${data.precisionPass ? 'green' : 'red'};">${data.precisionPass ? '✓ PASS' : '✗ FAIL'}</span></strong>
            `;
        }

        function updateOverallStatus(pipetteId) {
            const pipette = pipettes.find(p => p.id === pipetteId);
            if (!pipette) return;

            // Check As Found status - look at asFound status badges
            const asFoundElements = ['low', 'mid', 'high'].map(point =>
                document.getElementById(`status-asFound-${point}-${pipetteId}`)
            );
            const asFoundTested = asFoundElements.every(el => el && el.textContent !== 'PENDING');
            const asFoundPass = asFoundElements.every(el => el && el.textContent === 'PASS');

            if (asFoundTested) {
                pipette.statusAsFound = asFoundPass ? 'pass' : 'fail';
            } else {
                pipette.statusAsFound = 'pending';
            }

            // Check As Left status - look at asLeft status badges
            const asLeftElements = ['low', 'mid', 'high'].map(point =>
                document.getElementById(`status-asLeft-${point}-${pipetteId}`)
            );
            const asLeftTested = asLeftElements.every(el => el && el.textContent !== 'PENDING');
            const asLeftPass = asLeftElements.every(el => el && el.textContent === 'PASS');

            if (asLeftTested) {
                pipette.statusAsLeft = asLeftPass ? 'pass' : 'fail';
            } else {
                pipette.statusAsLeft = 'pending';
            }

            // Overall status (as-left takes precedence - final status after calibration)
            pipette.status = pipette.statusAsLeft;

            const overallStatus = document.getElementById(`status-${pipetteId}`);
            if (overallStatus) {
                // Show both statuses side-by-side
                const asFoundBadge = pipette.statusAsFound === 'pass' ? '✅ As Found: PASS' :
                                    pipette.statusAsFound === 'fail' ? '❌ As Found: FAIL' : '⏳ As Found: PENDING';
                const asLeftBadge = pipette.statusAsLeft === 'pass' ? '✅ As Left: PASS' :
                                   pipette.statusAsLeft === 'fail' ? '❌ As Left: FAIL' : '⏳ As Left: PENDING';

                overallStatus.className = '';
                overallStatus.innerHTML = `
                    <span class="status-badge status-${pipette.statusAsFound}" style="font-size: 0.85em; margin-right: 8px;">${asFoundBadge}</span>
                    <span class="status-badge status-${pipette.statusAsLeft}" style="font-size: 0.85em;">${asLeftBadge}</span>
                `;
            }
        }

        function updateProgress() {
            const total = pipettes.length;
            const completed = pipettes.filter(p => p.status !== 'pending').length;
            const progress = total > 0 ? (completed / total) * 100 : 0;
            
            const progressFill = document.getElementById('progressFill');
            if (progressFill) {
                progressFill.style.width = `${progress}%`;
            }
        }

        function removePipette(pipetteId) {
            pipettes = pipettes.filter(p => p.id !== pipetteId);
            const element = document.getElementById(`pipette-${pipetteId}`);
            if (element) element.remove();
            updateProgress();
            updateAnalysis();
            debouncedAutoSave();
        }

        function updateAnalysis() {
            const total = pipettes.length;
            const passed = pipettes.filter(p => p.status === 'pass').length;
            const failed = pipettes.filter(p => p.status === 'fail').length;
            const passRate = total > 0 ? ((passed / total) * 100).toFixed(1) : 0;

            const totalEl = document.getElementById('totalPipettes');
            const passEl = document.getElementById('passCount');
            const failEl = document.getElementById('failCount');
            const rateEl = document.getElementById('passRate');

            if (totalEl) totalEl.textContent = total;
            if (passEl) passEl.textContent = passed;
            if (failEl) failEl.textContent = failed;
            if (rateEl) rateEl.textContent = `${passRate}%`;

            const analysisDetails = document.getElementById('analysisDetails');
            if (analysisDetails) {
                analysisDetails.innerHTML = generateAnalysisDetails();
            }
        }

        function generateAnalysisDetails() {
            if (pipettes.length === 0) {
                return '<div class="alert alert-info">No pipettes added yet. Go to the Calibration tab to add pipettes.</div>';
            }

            let html = '<h3>📋 Detailed Analysis</h3>';

            pipettes.forEach(pipette => {
                const statusClass = pipette.status === 'pass' ? 'alert-success' : 
                                  pipette.status === 'fail' ? 'alert-danger' : 'alert-warning';
                
                html += `
                    <div class="alert ${statusClass}">
                        <h4>${pipette.brand} ${pipette.number} (${pipette.serial})</h4>
                        <p><strong>Volume Range:</strong> ${pipette.model} | <strong>Test Volume:</strong> ${pipette.testVolume} μL | <strong>Status:</strong> ${pipette.status.toUpperCase()}</p>
                        ${pipette.comments ? `<p><strong>Comments:</strong> ${pipette.comments}</p>` : ''}
                    </div>
                `;
            });

            return html;
        }

        function autoFillSampleData() {
            pipettes = [];
            document.getElementById('pipettesContainer').innerHTML = '';
            currentPipetteId = 0;

            const sampleData = [
                {
                    number: 'EQ-CPL-PIPS-D-035',
                    brand: 'Eppendorf',
                    pipetteModel: 'Research Plus',
                    serial: '3151046',
                    model: 'P-100',
                    volume: 100,
                    testVolume: 100,
                    channelType: 'single',
                    channelCount: 1,
                    measurements: {
                        asFound: {
                            low: [9.96, 9.97, 9.98, 9.95],
                            mid: [49.8, 49.7, 49.9, 49.85],
                            high: [99.6, 99.7, 99.8, 99.65]
                        },
                        asLeft: {
                            low: [9.99, 9.98, 9.96, 9.97],
                            mid: [49.9, 50.1, 49.8, 49.95],
                            high: [99.9, 99.8, 99.6, 99.75]
                        }
                    },
                    comments: 'Fixed'
                },
                {
                    number: 'EQ-CPL-PIPS-D-019',
                    brand: 'Eppendorf',
                    pipetteModel: 'Reference 2',
                    serial: '162061',
                    model: 'P-100',
                    volume: 100,
                    testVolume: 100,
                    channelType: 'single',
                    channelCount: 1,
                    measurements: {
                        asFound: {
                            low: [20.15, 20.2, 19.99, 20.05],
                            mid: [49.9, 49.7, 49.6, 49.8],
                            high: [99.9, 99.6, 99.7, 99.8]
                        },
                        asLeft: {
                            low: [20.15, 20.32, 20.25, 20.18],
                            mid: [50.1, 49.8, 50.0, 49.9],
                            high: [99.6, 99.8, 99.7, 99.75]
                        }
                    }
                },
                {
                    number: 'EQ-CPL-PIPS-D-007',
                    brand: 'Gilson',
                    pipetteModel: 'Pipetman P',
                    serial: 'Y56900K',
                    model: 'P-100',
                    volume: 100,
                    testVolume: 100,
                    channelType: 'single',
                    channelCount: 1,
                    measurements: {
                        asFound: {
                            low: [19.78, 19.74, 19.81, 19.77],
                            mid: [49.2, 49.7, 49.9, 49.6],
                            high: [99.5, 99.6, 99.5, 99.55]
                        },
                        asLeft: {
                            low: [19.64, 19.74, 19.59, 19.69],
                            mid: [49.9, 50.2, 49.9, 50.0],
                            high: [99.9, 99.8, 99.9, 99.85]
                        }
                    }
                },
                {
                    number: 'EQ-CPL-PIPS-M-008',
                    brand: 'Eppendorf',
                    pipetteModel: 'Research Plus 8-channel',
                    serial: 'M8151234',
                    model: 'P-100',
                    volume: 100,
                    testVolume: 100,
                    channelType: 'multi-8ch',
                    channelCount: 8,
                    measurements: {
                        asFound: {
                            low: [20.1, 19.9, 20.0, 19.95, 20.05, 19.92, 20.08, 19.98],
                            mid: [50.2, 49.8, 50.1, 49.9, 50.0, 49.95, 50.05, 49.85],
                            high: [100.5, 99.7, 100.2, 99.8, 100.0, 99.9, 100.1, 99.95]
                        },
                        asLeft: {
                            low: [20.0, 19.98, 20.02, 19.97, 20.01, 19.99, 20.03, 19.96],
                            mid: [50.1, 49.9, 50.05, 49.95, 50.0, 49.98, 50.02, 49.92],
                            high: [100.2, 99.9, 100.1, 99.95, 100.0, 99.98, 100.05, 99.92]
                        }
                    },
                    comments: 'Multi-channel calibrated'
                },
                {
                    number: 'EQ-CPL-PIPS-D-101',
                    brand: 'Gilson',
                    pipetteModel: 'Pipetman P',
                    serial: 'P2-12345',
                    model: 'P-2',
                    volume: 2,
                    testVolume: 2,
                    channelType: 'single',
                    channelCount: 1,
                    measurements: {
                        asFound: {
                            low: [0.495, 0.502, 0.498, 0.501],
                            mid: [0.998, 1.002, 0.995, 1.001],
                            high: [1.995, 2.002, 1.998, 2.001]
                        },
                        asLeft: {
                            low: [0.498, 0.501, 0.499, 0.502],
                            mid: [0.999, 1.001, 0.998, 1.002],
                            high: [1.998, 2.001, 1.999, 2.002]
                        }
                    },
                    comments: 'Small volume pipette'
                },
                {
                    number: 'EQ-CPL-PIPS-D-102',
                    brand: 'Eppendorf',
                    pipetteModel: 'Reference 2',
                    serial: 'P10-67890',
                    model: 'P-10',
                    volume: 10,
                    testVolume: 10,
                    channelType: 'single',
                    channelCount: 1,
                    measurements: {
                        asFound: {
                            low: [1.98, 2.01, 1.99, 2.02],
                            mid: [4.97, 5.02, 4.99, 5.01],
                            high: [9.95, 10.02, 9.98, 10.01]
                        },
                        asLeft: {
                            low: [1.99, 2.00, 2.01, 1.98],
                            mid: [4.98, 5.01, 4.99, 5.02],
                            high: [9.97, 10.01, 9.99, 10.02]
                        }
                    },
                    comments: 'Good precision'
                },
                {
                    number: 'EQ-CPL-PIPS-D-103',
                    brand: 'Gilson',
                    pipetteModel: 'Pipetman P',
                    serial: 'P20-11223',
                    model: 'P-20',
                    volume: 20,
                    testVolume: 20,
                    channelType: 'single',
                    channelCount: 1,
                    measurements: {
                        asFound: {
                            low: [4.95, 5.02, 4.98, 5.01],
                            mid: [9.96, 10.03, 9.99, 10.02],
                            high: [19.92, 20.05, 19.98, 20.01]
                        },
                        asLeft: {
                            low: [4.98, 5.01, 4.99, 5.02],
                            mid: [9.98, 10.01, 9.99, 10.02],
                            high: [19.96, 20.02, 19.99, 20.01]
                        }
                    }
                },
                {
                    number: 'EQ-CPL-PIPS-D-104',
                    brand: 'Eppendorf',
                    pipetteModel: 'Research Plus',
                    serial: 'P200-55667',
                    model: 'P-200',
                    volume: 200,
                    testVolume: 200,
                    channelType: 'single',
                    channelCount: 1,
                    measurements: {
                        asFound: {
                            low: [49.5, 50.2, 49.8, 50.1],
                            mid: [99.6, 100.3, 99.9, 100.2],
                            high: [199.2, 200.5, 199.8, 200.1]
                        },
                        asLeft: {
                            low: [49.8, 50.1, 49.9, 50.2],
                            mid: [99.8, 100.1, 99.9, 100.2],
                            high: [199.6, 200.2, 199.9, 200.1]
                        }
                    },
                    comments: 'Excellent accuracy'
                },
                {
                    number: 'EQ-CPL-PIPS-M-009',
                    brand: 'Eppendorf',
                    pipetteModel: 'Research Plus 8-channel',
                    serial: 'M200-88990',
                    model: 'P-200',
                    volume: 200,
                    testVolume: 200,
                    channelType: 'multi-8ch',
                    channelCount: 8,
                    measurements: {
                        asFound: {
                            low: [50.1, 49.8, 50.2, 49.9, 50.0, 49.95, 50.05, 49.92],
                            mid: [100.2, 99.7, 100.1, 99.9, 100.0, 99.85, 100.05, 99.95],
                            high: [200.5, 199.6, 200.2, 199.8, 200.0, 199.9, 200.1, 199.95]
                        },
                        asLeft: {
                            low: [50.0, 49.9, 50.1, 49.95, 50.02, 49.98, 50.03, 49.96],
                            mid: [100.1, 99.9, 100.05, 99.95, 100.0, 99.92, 100.02, 99.98],
                            high: [200.2, 199.8, 200.1, 199.95, 200.0, 199.95, 200.05, 199.92]
                        }
                    },
                    comments: 'Multi-channel P-200'
                },
                {
                    number: 'EQ-CPL-PIPS-D-105',
                    brand: 'Gilson',
                    pipetteModel: 'Pipetman P',
                    serial: 'P1000-33445',
                    model: 'P-1000',
                    volume: 1000,
                    testVolume: 1000,
                    channelType: 'single',
                    channelCount: 1,
                    measurements: {
                        asFound: {
                            low: [199.2, 200.5, 199.8, 200.2],
                            mid: [498.5, 501.2, 499.8, 500.5],
                            high: [995.0, 1003.5, 998.2, 1001.0]
                        },
                        asLeft: {
                            low: [199.6, 200.2, 199.9, 200.1],
                            mid: [499.2, 500.5, 499.8, 500.2],
                            high: [997.5, 1001.8, 999.2, 1000.5]
                        }
                    },
                    comments: 'Large volume pipette'
                },
                {
                    number: 'EQ-CPL-PIPS-D-106',
                    brand: 'Eppendorf',
                    pipetteModel: 'Reference 2',
                    serial: 'P5000-77889',
                    model: 'P-5000',
                    volume: 5000,
                    testVolume: 5000,
                    channelType: 'single',
                    channelCount: 1,
                    measurements: {
                        asFound: {
                            low: [995.0, 1005.0, 998.5, 1001.5],
                            mid: [2490.0, 2510.0, 2498.0, 2502.5],
                            high: [4980.0, 5020.0, 4995.0, 5005.0]
                        },
                        asLeft: {
                            low: [998.0, 1002.0, 999.5, 1000.5],
                            mid: [2495.0, 2505.0, 2499.0, 2501.0],
                            high: [4990.0, 5010.0, 4998.0, 5002.0]
                        }
                    },
                    comments: 'Very large volume'
                },
                {
                    number: 'EQ-CPL-PIPS-D-107',
                    brand: 'Gilson',
                    pipetteModel: 'Pipetman P',
                    serial: 'P2.5-44556',
                    model: 'P-2.5',
                    volume: 2.5,
                    testVolume: 2.5,
                    channelType: 'single',
                    channelCount: 1,
                    measurements: {
                        asFound: {
                            low: [0.495, 0.502, 0.498, 0.501],
                            mid: [1.245, 1.252, 1.248, 1.251],
                            high: [2.495, 2.502, 2.498, 2.501]
                        },
                        asLeft: {
                            low: [0.498, 0.501, 0.499, 0.502],
                            mid: [1.248, 1.251, 1.249, 1.252],
                            high: [2.498, 2.501, 2.499, 2.502]
                        }
                    },
                    comments: 'Irregular pattern - P-2.5'
                },
                {
                    number: 'EQ-CPL-PIPS-D-108',
                    brand: 'Eppendorf',
                    pipetteModel: 'Research Plus',
                    serial: 'P25-66778',
                    model: 'P-25',
                    volume: 25,
                    testVolume: 25,
                    channelType: 'single',
                    channelCount: 1,
                    measurements: {
                        asFound: {
                            low: [4.96, 5.03, 4.99, 5.02],
                            mid: [12.45, 12.53, 12.48, 12.51],
                            high: [24.92, 25.06, 24.98, 25.02]
                        },
                        asLeft: {
                            low: [4.98, 5.01, 4.99, 5.02],
                            mid: [12.48, 12.51, 12.49, 12.52],
                            high: [24.96, 25.02, 24.99, 25.01]
                        }
                    },
                    comments: 'Irregular pattern - P-25'
                },
                {
                    number: 'EQ-CPL-PIPS-D-109',
                    brand: 'Gilson',
                    pipetteModel: 'Pipetman P',
                    serial: 'P250-99001',
                    model: 'P-250',
                    volume: 250,
                    testVolume: 250,
                    channelType: 'single',
                    channelCount: 1,
                    measurements: {
                        asFound: {
                            low: [49.5, 50.3, 49.8, 50.2],
                            mid: [124.2, 125.5, 124.8, 125.2],
                            high: [248.5, 251.2, 249.6, 250.3]
                        },
                        asLeft: {
                            low: [49.8, 50.1, 49.9, 50.2],
                            mid: [124.6, 125.2, 124.9, 125.1],
                            high: [249.2, 250.5, 249.8, 250.2]
                        }
                    },
                    comments: 'Irregular pattern - P-250'
                },
                {
                    number: 'EQ-CPL-PIPS-D-110',
                    brand: 'Eppendorf',
                    pipetteModel: 'Reference 2',
                    serial: 'P1200-22334',
                    model: 'P-1200',
                    volume: 1200,
                    testVolume: 1200,
                    channelType: 'single',
                    channelCount: 1,
                    measurements: {
                        asFound: {
                            low: [248.5, 251.2, 249.6, 250.3],
                            mid: [597.0, 603.5, 599.2, 601.8],
                            high: [1192.0, 1208.5, 1198.5, 1203.2]
                        },
                        asLeft: {
                            low: [249.2, 250.5, 249.8, 250.2],
                            mid: [599.0, 601.5, 599.8, 600.8],
                            high: [1196.0, 1204.2, 1199.5, 1201.8]
                        }
                    },
                    comments: 'Irregular pattern - P-1200'
                }
            ];

            sampleData.forEach(data => {
                currentPipetteId++;
                const pipette = {
                    id: currentPipetteId,
                    ...data,
                    status: 'pending'
                };
                pipettes.push(pipette);
                renderPipette(pipette);
                
                ['asFound', 'asLeft'].forEach(condition => {
                    ['low', 'mid', 'high'].forEach(point => {
                        validateMeasurement(pipette.id, condition, point);
                    });
                });
                updateOverallStatus(pipette.id);
            });

            updateProgress();
            updateAnalysis();
        }

        function getSessionInfo() {
            return {
                serviceProvider: document.getElementById('serviceProvider')?.value || '',
                location: document.getElementById('location')?.value || '',
                address: document.getElementById('address')?.value || '',
                client: document.getElementById('client')?.value || '',
                technician: document.getElementById('technician')?.value || '',
                calDate: document.getElementById('calDate')?.value || '',
                dueDate: document.getElementById('dueDate')?.value || '',
                frequency: document.getElementById('frequency')?.value || '',
                temperature: document.getElementById('temperature')?.value || '',
                humidity: document.getElementById('humidity')?.value || '',
                pressure: document.getElementById('pressure')?.value || '',
                balanceSerial: document.getElementById('balanceSerial')?.value || '',
                balanceCalDate: document.getElementById('balanceCalDate')?.value || '',
                balanceDueDate: document.getElementById('balanceDueDate')?.value || ''
            };
        }

        function generateReport() {
            const reportContent = document.getElementById('reportContent');
            if (!reportContent) return;

            const sessionInfo = getSessionInfo();
            const certNumber = `CERT-${new Date(sessionInfo.calDate).getFullYear()}-${String(Math.floor(Math.random() * 10000)).padStart(4, '0')}`;

            let html = `
                <!-- Professional Header -->
                <div style="border-bottom: 3px solid #667eea; padding-bottom: 20px; margin-bottom: 30px;">
                    <div style="display: flex; justify-content: space-between; align-items: start;">
                        <div>
                            <h1 style="margin: 0; color: #2c5282; font-size: 28px;">PIPETTE CALIBRATION CERTIFICATE</h1>
                            <p style="color: #6c757d; margin: 5px 0;">ISO 8655 Compliant | Service Level 3</p>
                        </div>
                        <div style="text-align: right;">
                            <p style="margin: 0;"><strong>Certificate No:</strong> ${certNumber}</p>
                            <p style="margin: 5px 0;"><strong>Issue Date:</strong> ${new Date().toLocaleDateString()}</p>
                        </div>
                    </div>
                </div>

                <!-- Service Information and Environmental Conditions -->
                <table style="width: 100%; border-collapse: collapse; margin-bottom: 30px; border: 1px solid #ddd;">
                    <tr style="background: #f8f9fa;">
                        <td colspan="4" style="padding: 10px; font-weight: bold; border: 1px solid #ddd;">SERVICE INFORMATION</td>
                    </tr>
                    <tr>
                        <td style="padding: 8px; border: 1px solid #ddd; width: 25%;"><strong>Service Provider:</strong></td>
                        <td style="padding: 8px; border: 1px solid #ddd; width: 25%;">${sessionInfo.serviceProvider || 'N/A'}</td>
                        <td style="padding: 8px; border: 1px solid #ddd; width: 25%;"><strong>Client:</strong></td>
                        <td style="padding: 8px; border: 1px solid #ddd; width: 25%;">${sessionInfo.client || 'N/A'}</td>
                    </tr>
                    <tr>
                        <td style="padding: 8px; border: 1px solid #ddd;"><strong>Location:</strong></td>
                        <td style="padding: 8px; border: 1px solid #ddd;">${sessionInfo.location || 'N/A'}</td>
                        <td style="padding: 8px; border: 1px solid #ddd;"><strong>Address:</strong></td>
                        <td style="padding: 8px; border: 1px solid #ddd;">${sessionInfo.address || 'N/A'}</td>
                    </tr>
                    <tr>
                        <td style="padding: 8px; border: 1px solid #ddd;"><strong>Technician:</strong></td>
                        <td style="padding: 8px; border: 1px solid #ddd;">${sessionInfo.technician || 'N/A'}</td>
                        <td style="padding: 8px; border: 1px solid #ddd;"><strong>Calibration Date:</strong></td>
                        <td style="padding: 8px; border: 1px solid #ddd;">${sessionInfo.calDate || 'N/A'}</td>
                    </tr>
                    <tr style="background: #f8f9fa;">
                        <td colspan="4" style="padding: 10px; font-weight: bold; border: 1px solid #ddd;">ENVIRONMENTAL CONDITIONS & EQUIPMENT</td>
                    </tr>
                    <tr>
                        <td style="padding: 8px; border: 1px solid #ddd;"><strong>Temperature:</strong></td>
                        <td style="padding: 8px; border: 1px solid #ddd;">${sessionInfo.temperature || 'N/A'}°C ± 0.5°C</td>
                        <td style="padding: 8px; border: 1px solid #ddd;"><strong>Humidity:</strong></td>
                        <td style="padding: 8px; border: 1px solid #ddd;">${sessionInfo.humidity || 'N/A'}% RH</td>
                    </tr>
                    <tr>
                        <td style="padding: 8px; border: 1px solid #ddd;"><strong>Pressure:</strong></td>
                        <td style="padding: 8px; border: 1px solid #ddd;">${sessionInfo.pressure || 'N/A'} kPa</td>
                        <td style="padding: 8px; border: 1px solid #ddd;"><strong>Balance S/N:</strong></td>
                        <td style="padding: 8px; border: 1px solid #ddd;">${sessionInfo.balanceSerial || 'N/A'}</td>
                    </tr>
                    <tr>
                        <td style="padding: 8px; border: 1px solid #ddd;"><strong>Balance Cal Date:</strong></td>
                        <td style="padding: 8px; border: 1px solid #ddd;">${sessionInfo.balanceCalDate || 'N/A'}</td>
                        <td style="padding: 8px; border: 1px solid #ddd;"><strong>Balance Due Date:</strong></td>
                        <td style="padding: 8px; border: 1px solid #ddd;">${sessionInfo.balanceDueDate || 'N/A'}</td>
                    </tr>
                </table>

                <!-- Summary Statistics -->
                <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 30px;">
                    <h3 style="margin-top: 0;">Calibration Summary</h3>
                    <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px; text-align: center;">
                        <div>
                            <div style="font-size: 24px; font-weight: bold; color: #667eea;">${pipettes.length}</div>
                            <div style="color: #6c757d; font-size: 14px;">Total Pipettes</div>
                        </div>
                        <div>
                            <div style="font-size: 24px; font-weight: bold; color: #28a745;">${pipettes.filter(p => p.status === 'pass').length}</div>
                            <div style="color: #6c757d; font-size: 14px;">Passed</div>
                        </div>
                        <div>
                            <div style="font-size: 24px; font-weight: bold; color: #dc3545;">${pipettes.filter(p => p.status === 'fail').length}</div>
                            <div style="color: #6c757d; font-size: 14px;">Failed</div>
                        </div>
                        <div>
                            <div style="font-size: 24px; font-weight: bold; color: #667eea;">${pipettes.length > 0 ? ((pipettes.filter(p => p.status === 'pass').length / pipettes.length) * 100).toFixed(1) : 0}%</div>
                            <div style="color: #6c757d; font-size: 14px;">Pass Rate</div>
                        </div>
                    </div>
                </div>

                <!-- Individual Pipette Results -->
                <h2 style="color: #2c5282; border-bottom: 2px solid #667eea; padding-bottom: 10px;">DETAILED CALIBRATION RESULTS</h2>
            `;

            // Generate detailed results for each pipette
            pipettes.forEach((pipette, index) => {
                html += generatePipetteDetailedReport(pipette, index + 1);
            });

            // Footer
            html += `
                <div style="margin-top: 40px; padding-top: 20px; border-top: 2px solid #ddd;">
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 30px; margin-bottom: 20px;">
                        <div>
                            <p><strong>Calibration Standard:</strong> ISO 8655 (Piston-operated volumetric apparatus)</p>
                            <p><strong>Traceability:</strong> Measurements traceable to NIST standards</p>
                            <p><strong>Method:</strong> Gravimetric analysis (ISO 8655-6)</p>
                        </div>
                        <div>
                            <p><strong>Service Level:</strong> Level 3 (4 As Found + 4 As Left measurements)</p>
                            <p><strong>Next Calibration Due:</strong> ${sessionInfo.dueDate || 'N/A'}</p>
                            <p><strong>Calibration Frequency:</strong> ${sessionInfo.frequency || 'N/A'}</p>
                        </div>
                    </div>

                    <div style="margin-top: 30px;">
                        <p style="font-style: italic; color: #6c757d;">
                            This certificate is valid only for the equipment tested under the conditions stated above.
                            The reported results reflect the status of the equipment at the time of calibration.
                        </p>
                    </div>

                    <div style="margin-top: 30px; padding-top: 20px; border-top: 1px solid #ddd;">
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 40px;">
                            <div>
                                <p style="margin-bottom: 40px;">Technician Signature:</p>
                                <p style="border-bottom: 1px solid #000; display: inline-block; min-width: 200px;"></p>
                                <p style="margin-top: 5px; font-size: 12px;">${sessionInfo.technician || ''}</p>
                            </div>
                            <div style="text-align: right;">
                                <p><strong>Issue Date:</strong> ${new Date().toLocaleDateString()}</p>
                                <p><strong>Issue Time:</strong> ${new Date().toLocaleTimeString()}</p>
                            </div>
                        </div>
                    </div>
                </div>
            `;

            reportContent.innerHTML = html;
        }

        function generatePipetteDetailedReport(pipette, number) {
            const testPoints = [
                { name: 'Low', key: 'low', volume: getNominalVolume('low', pipette.model) },
                { name: 'Mid', key: 'mid', volume: getNominalVolume('mid', pipette.model) },
                { name: 'High', key: 'high', volume: getNominalVolume('high', pipette.model) }
            ];

            let html = `
                <div style="page-break-inside: avoid; margin-top: 30px; border: 1px solid #ddd; padding: 20px; border-radius: 8px;">
                    <h3 style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 12px; margin: -20px -20px 20px -20px; border-radius: 8px 8px 0 0;">
                        Pipette #${number} - ${pipette.number || 'N/A'}
                        <span style="float: right; font-size: 18px;">${pipette.status === 'pass' ? '✓ PASS' : pipette.status === 'fail' ? '✗ FAIL' : '⏳ PENDING'}</span>
                    </h3>

                    <!-- Pipette Identification -->
                    <table style="width: 100%; border-collapse: collapse; margin-bottom: 20px; font-size: 14px;">
                        <tr>
                            <td style="padding: 6px; border: 1px solid #ddd; background: #f8f9fa; width: 25%;"><strong>Brand:</strong></td>
                            <td style="padding: 6px; border: 1px solid #ddd; width: 25%;">${pipette.brand || 'N/A'}</td>
                            <td style="padding: 6px; border: 1px solid #ddd; background: #f8f9fa; width: 25%;"><strong>Model:</strong></td>
                            <td style="padding: 6px; border: 1px solid #ddd; width: 25%;">${pipette.pipetteModel || 'N/A'}</td>
                        </tr>
                        <tr>
                            <td style="padding: 6px; border: 1px solid #ddd; background: #f8f9fa;"><strong>Serial Number:</strong></td>
                            <td style="padding: 6px; border: 1px solid #ddd;">${pipette.serial || 'N/A'}</td>
                            <td style="padding: 6px; border: 1px solid #ddd; background: #f8f9fa;"><strong>Volume Range:</strong></td>
                            <td style="padding: 6px; border: 1px solid #ddd;">${pipette.model || 'N/A'}</td>
                        </tr>
                        <tr>
                            <td style="padding: 6px; border: 1px solid #ddd; background: #f8f9fa;"><strong>Type:</strong></td>
                            <td style="padding: 6px; border: 1px solid #ddd;">${pipette.channelType === 'single' ? 'Single Channel' : `Multi-Channel (${pipette.channelCount}ch)`}</td>
                            <td style="padding: 6px; border: 1px solid #ddd; background: #f8f9fa;"><strong>Comments:</strong></td>
                            <td style="padding: 6px; border: 1px solid #ddd;">${pipette.comments || 'None'}</td>
                        </tr>
                    </table>
            `;

            if (pipette.channelType === 'single') {
                html += generateSingleChannelResults(pipette, testPoints);
            } else {
                html += generateMultiChannelResults(pipette, testPoints);
            }

            html += `</div>`;
            return html;
        }

        function generateSingleChannelResults(pipette, testPoints) {
            let html = `
                <h4 style="color: #2c5282; margin-top: 20px;">As Found Measurements</h4>
                <table style="width: 100%; border-collapse: collapse; margin-bottom: 20px; font-size: 13px;">
                    <thead>
                        <tr style="background: #667eea; color: white;">
                            <th style="padding: 10px; border: 1px solid #ddd; text-align: left;">Test Point</th>
                            <th style="padding: 10px; border: 1px solid #ddd; text-align: center;">Nominal (μL)</th>
                            <th style="padding: 10px; border: 1px solid #ddd; text-align: center;">R1</th>
                            <th style="padding: 10px; border: 1px solid #ddd; text-align: center;">R2</th>
                            <th style="padding: 10px; border: 1px solid #ddd; text-align: center;">R3</th>
                            <th style="padding: 10px; border: 1px solid #ddd; text-align: center;">R4</th>
                            <th style="padding: 10px; border: 1px solid #ddd; text-align: center;">Mean</th>
                            <th style="padding: 10px; border: 1px solid #ddd; text-align: center;">CV%</th>
                            <th style="padding: 10px; border: 1px solid #ddd; text-align: center;">Result</th>
                        </tr>
                    </thead>
                    <tbody>
            `;

            testPoints.forEach(point => {
                const measurements = pipette.measurements.asFound[point.key];
                const mean = measurements.reduce((a, b) => a + b, 0) / measurements.length;
                const cv = calculateCV(measurements);
                const specs = getSpecifications(pipette.model, point.volume, false);
                const pass = specs && measurements.every(m => m >= specs.accuracy.from && m <= specs.accuracy.to);

                html += `
                    <tr>
                        <td style="padding: 8px; border: 1px solid #ddd;"><strong>${point.name}</strong></td>
                        <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">${formatVolume(point.volume)}</td>
                        <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">${formatVolume(measurements[0])}</td>
                        <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">${formatVolume(measurements[1])}</td>
                        <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">${formatVolume(measurements[2])}</td>
                        <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">${formatVolume(measurements[3])}</td>
                        <td style="padding: 8px; border: 1px solid #ddd; text-align: center; font-weight: bold;">${formatVolume(mean)}</td>
                        <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">${cv.toFixed(2)}%</td>
                        <td style="padding: 8px; border: 1px solid #ddd; text-align: center; color: ${pass ? '#28a745' : '#dc3545'}; font-weight: bold;">${pass ? '✓ PASS' : '✗ FAIL'}</td>
                    </tr>
                `;
            });

            html += `
                    </tbody>
                </table>

                <h4 style="color: #2c5282; margin-top: 20px;">As Left Measurements</h4>
                <table style="width: 100%; border-collapse: collapse; margin-bottom: 10px; font-size: 13px;">
                    <thead>
                        <tr style="background: #667eea; color: white;">
                            <th style="padding: 10px; border: 1px solid #ddd; text-align: left;">Test Point</th>
                            <th style="padding: 10px; border: 1px solid #ddd; text-align: center;">Nominal (μL)</th>
                            <th style="padding: 10px; border: 1px solid #ddd; text-align: center;">R1</th>
                            <th style="padding: 10px; border: 1px solid #ddd; text-align: center;">R2</th>
                            <th style="padding: 10px; border: 1px solid #ddd; text-align: center;">R3</th>
                            <th style="padding: 10px; border: 1px solid #ddd; text-align: center;">R4</th>
                            <th style="padding: 10px; border: 1px solid #ddd; text-align: center;">Mean</th>
                            <th style="padding: 10px; border: 1px solid #ddd; text-align: center;">CV%</th>
                            <th style="padding: 10px; border: 1px solid #ddd; text-align: center;">Result</th>
                        </tr>
                    </thead>
                    <tbody>
            `;

            testPoints.forEach(point => {
                const measurements = pipette.measurements.asLeft[point.key];
                const mean = measurements.reduce((a, b) => a + b, 0) / measurements.length;
                const cv = calculateCV(measurements);
                const specs = getSpecifications(pipette.model, point.volume, false);
                const pass = specs && measurements.every(m => m >= specs.accuracy.from && m <= specs.accuracy.to);

                html += `
                    <tr>
                        <td style="padding: 8px; border: 1px solid #ddd;"><strong>${point.name}</strong></td>
                        <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">${formatVolume(point.volume)}</td>
                        <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">${formatVolume(measurements[0])}</td>
                        <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">${formatVolume(measurements[1])}</td>
                        <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">${formatVolume(measurements[2])}</td>
                        <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">${formatVolume(measurements[3])}</td>
                        <td style="padding: 8px; border: 1px solid #ddd; text-align: center; font-weight: bold;">${formatVolume(mean)}</td>
                        <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">${cv.toFixed(2)}%</td>
                        <td style="padding: 8px; border: 1px solid #ddd; text-align: center; color: ${pass ? '#28a745' : '#dc3545'}; font-weight: bold;">${pass ? '✓ PASS' : '✗ FAIL'}</td>
                    </tr>
                `;
            });

            html += `
                    </tbody>
                </table>
            `;

            return html;
        }

        function generateMultiChannelResults(pipette, testPoints) {
            // For multi-channel, show calculated statistics across all channels
            let html = `
                <h4 style="color: #2c5282; margin-top: 20px;">As Found Measurements (Across All Channels)</h4>
                <table style="width: 100%; border-collapse: collapse; margin-bottom: 20px; font-size: 13px;">
                    <thead>
                        <tr style="background: #667eea; color: white;">
                            <th style="padding: 10px; border: 1px solid #ddd; text-align: left;">Test Point</th>
                            <th style="padding: 10px; border: 1px solid #ddd; text-align: center;">Nominal (μL)</th>
                            <th style="padding: 10px; border: 1px solid #ddd; text-align: center;">Mean</th>
                            <th style="padding: 10px; border: 1px solid #ddd; text-align: center;">CV%</th>
                            <th style="padding: 10px; border: 1px solid #ddd; text-align: center;">SD (μL)</th>
                            <th style="padding: 10px; border: 1px solid #ddd; text-align: center;">Result</th>
                        </tr>
                    </thead>
                    <tbody>
            `;

            testPoints.forEach(point => {
                const measurements = [];
                for (let ch = 0; ch < pipette.channelCount; ch++) {
                    measurements.push(pipette.measurements.asFound[point.key][ch]);
                }
                const mean = measurements.reduce((a, b) => a + b, 0) / measurements.length;
                const cv = calculateCV(measurements);
                const sd = calculateSD(measurements);
                const specs = getSpecifications(pipette.model, point.volume, true);
                const pass = specs && measurements.every(m => m >= specs.accuracy.from && m <= specs.accuracy.to);

                html += `
                    <tr>
                        <td style="padding: 8px; border: 1px solid #ddd;"><strong>${point.name}</strong></td>
                        <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">${formatVolume(point.volume)}</td>
                        <td style="padding: 8px; border: 1px solid #ddd; text-align: center; font-weight: bold;">${formatVolume(mean)}</td>
                        <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">${cv.toFixed(2)}%</td>
                        <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">${formatVolume(sd)}</td>
                        <td style="padding: 8px; border: 1px solid #ddd; text-align: center; color: ${pass ? '#28a745' : '#dc3545'}; font-weight: bold;">${pass ? '✓ PASS' : '✗ FAIL'}</td>
                    </tr>
                `;
            });

            html += `
                    </tbody>
                </table>

                <h4 style="color: #2c5282; margin-top: 20px;">As Left Measurements (Across All Channels)</h4>
                <table style="width: 100%; border-collapse: collapse; margin-bottom: 10px; font-size: 13px;">
                    <thead>
                        <tr style="background: #667eea; color: white;">
                            <th style="padding: 10px; border: 1px solid #ddd; text-align: left;">Test Point</th>
                            <th style="padding: 10px; border: 1px solid #ddd; text-align: center;">Nominal (μL)</th>
                            <th style="padding: 10px; border: 1px solid #ddd; text-align: center;">Mean</th>
                            <th style="padding: 10px; border: 1px solid #ddd; text-align: center;">CV%</th>
                            <th style="padding: 10px; border: 1px solid #ddd; text-align: center;">SD (μL)</th>
                            <th style="padding: 10px; border: 1px solid #ddd; text-align: center;">Result</th>
                        </tr>
                    </thead>
                    <tbody>
            `;

            testPoints.forEach(point => {
                const measurements = [];
                for (let ch = 0; ch < pipette.channelCount; ch++) {
                    measurements.push(pipette.measurements.asLeft[point.key][ch]);
                }
                const mean = measurements.reduce((a, b) => a + b, 0) / measurements.length;
                const cv = calculateCV(measurements);
                const sd = calculateSD(measurements);
                const specs = getSpecifications(pipette.model, point.volume, true);
                const pass = specs && measurements.every(m => m >= specs.accuracy.from && m <= specs.accuracy.to);

                html += `
                    <tr>
                        <td style="padding: 8px; border: 1px solid #ddd;"><strong>${point.name}</strong></td>
                        <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">${formatVolume(point.volume)}</td>
                        <td style="padding: 8px; border: 1px solid #ddd; text-align: center; font-weight: bold;">${formatVolume(mean)}</td>
                        <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">${cv.toFixed(2)}%</td>
                        <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">${formatVolume(sd)}</td>
                        <td style="padding: 8px; border: 1px solid #ddd; text-align: center; color: ${pass ? '#28a745' : '#dc3545'}; font-weight: bold;">${pass ? '✓ PASS' : '✗ FAIL'}</td>
                    </tr>
                `;
            });

            html += `
                    </tbody>
                </table>
            `;

            return html;
        }

        function saveSession() {
            const sessionData = {
                sessionInfo: getSessionInfo(),
                pipettes: pipettes,
                timestamp: new Date().toISOString()
            };

            const dataStr = JSON.stringify(sessionData, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `pipette_calibration_${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);

            alert('Session saved successfully!');
        }

        function loadHistory() {
            const sessions = JSON.parse(localStorage.getItem('calibrationSessions') || '[]');
            const historyContainer = document.getElementById('historyContainer');

            if (!historyContainer) return;

            if (sessions.length === 0) {
                historyContainer.innerHTML = '<div class="alert alert-info">No calibration history found. Sessions will appear here after you save them.</div>';
                return;
            }

            let html = '';
            sessions.forEach(session => {
                const date = new Date(session.lastModified || session.timestamp);
                const dateStr = date.toLocaleString();
                const pipetteCount = (session.pipettes || []).length;
                const passCount = (session.pipettes || []).filter(p => p.status === 'pass').length;
                const failCount = (session.pipettes || []).filter(p => p.status === 'fail').length;
                const isCurrent = session.id === currentSessionId;

                html += `
                    <div class="session-card" onclick="loadSessionFromHistory('${session.id}')">
                        <div class="session-card-header">
                            <div>
                                <div class="session-date">${dateStr}</div>
                                ${isCurrent ? '<span class="status-badge status-pending" style="margin-left: 10px;">CURRENT</span>' : ''}
                            </div>
                            <button class="btn btn-danger btn-sm" onclick="deleteSession('${session.id}', event)">Delete</button>
                        </div>
                        <div class="session-stats">
                            <span class="session-stat">Technician: ${session.sessionInfo?.technician || 'N/A'}</span>
                            <span class="session-stat">Location: ${session.sessionInfo?.location || 'N/A'}</span>
                        </div>
                        <div class="session-stats">
                            <span class="session-stat">Total: ${pipetteCount} pipettes</span>
                            <span class="session-stat" style="color: #28a745;">Passed: ${passCount}</span>
                            <span class="session-stat" style="color: #dc3545;">Failed: ${failCount}</span>
                        </div>
                    </div>
                `;
            });

            historyContainer.innerHTML = html;
        }

        function downloadPDF() {
            generateReport();
            window.print();
        }

        function printReport() {
            generateReport();
            window.print();
        }

        // ========== CSV Export Functions ==========

        function exportFormattedCSV() {
            const sessionInfo = getSessionInfo();
            let csv = '';

            // Header section
            csv += `Platinum SC Data Intake Worksheets,,,,,,,,,Tech:,${sessionInfo.technician}\n`;
            csv += `Platinum Service,Location:,${sessionInfo.location},,,,,Address:,${sessionInfo.address}\n`;
            csv += `Cal Date:,${sessionInfo.calDate},Client:,${sessionInfo.client},,,,,Bal SN:,${sessionInfo.balanceSerial},Bal Cal Date:,${sessionInfo.balanceCalDate}\n`;
            csv += `Cal Due:,${sessionInfo.dueDate},Frequency:,${sessionInfo.frequency},,,,,Temp:,${sessionInfo.temperature},Bal Due Date:,${sessionInfo.balanceDueDate}\n`;
            csv += `\n`;

            // Export each pipette separately (single and multi-channel have different formats)
            pipettes.forEach((pipette, idx) => {
                csv += `\n--- Pipette ${idx + 1} ---\n`;
                csv += `Pipette #:,${pipette.number}\n`;
                csv += `Brand:,${pipette.brand}\n`;
                csv += `Serial#:,${pipette.serial}\n`;
                csv += `Vol:,${pipette.testVolume}\n`;
                csv += `Type:,${pipette.channelType === 'single' ? 'Single Channel' : `Multi-Channel (${pipette.channelCount}ch)`}\n`;
                csv += `\n`;

                if (pipette.channelType === 'single') {
                    // Single channel format
                    csv += `,As Found,,,,,As Left,,,\n`;
                    csv += `,Low,Mid,High,,Low,Mid,High\n`;
                    for (let i = 0; i < 4; i++) {
                        csv += `Reading ${i + 1},${pipette.measurements.asFound.low[i] || ''},${pipette.measurements.asFound.mid[i] || ''},${pipette.measurements.asFound.high[i] || ''},,`;
                        csv += `${pipette.measurements.asLeft.low[i] || ''},${pipette.measurements.asLeft.mid[i] || ''},${pipette.measurements.asLeft.high[i] || ''}\n`;
                    }
                } else {
                    // Multi-channel format
                    csv += `Channel,As Found Low,As Found Mid,As Found High,As Left Low,As Left Mid,As Left High\n`;
                    for (let ch = 0; ch < pipette.channelCount; ch++) {
                        csv += `Channel ${ch + 1},`;
                        csv += `${pipette.measurements.asFound.low[ch] || ''},${pipette.measurements.asFound.mid[ch] || ''},${pipette.measurements.asFound.high[ch] || ''},`;
                        csv += `${pipette.measurements.asLeft.low[ch] || ''},${pipette.measurements.asLeft.mid[ch] || ''},${pipette.measurements.asLeft.high[ch] || ''}\n`;
                    }
                }

                csv += `Comments:,"${pipette.comments || ''}"\n`;
                csv += `\n`;
            });

            // Download CSV
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `calibration_worksheet_${new Date().toISOString().split('T')[0]}.csv`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        function exportDataCSV() {
            const sessionInfo = getSessionInfo();
            let csv = '';

            // CSV Headers - flexible for both single and multi-channel
            csv += 'Date,Technician,Location,Client,Pipette Number,Brand,Model,Serial,Volume,Channel Type,Channel,Test Point,Condition,Measurement,Status,Comments\n';

            // Data rows
            pipettes.forEach(pipette => {
                if (pipette.channelType === 'single') {
                    // Single channel: 4 readings per test point
                    ['low', 'mid', 'high'].forEach(point => {
                        ['asFound', 'asLeft'].forEach(condition => {
                            const measurements = pipette.measurements[condition][point];
                            if (measurements.filter(m => m !== '').length === 4) {
                                const mean = measurements.reduce((a, b) => a + b, 0) / 4;
                                const cv = calculateCV(measurements);
                                const sd = calculateSD(measurements);

                                const nominalVolume = getNominalVolume(point, pipette.model);
                                const specs = getSpecifications(pipette.model, nominalVolume, false);

                                let status = 'PENDING';
                                if (specs) {
                                    const accuracyPass = measurements.every(reading =>
                                        reading >= specs.accuracy.from && reading <= specs.accuracy.to
                                    );
                                    const cvPass = cv <= specs.precision.percent;
                                    const sdPass = sd <= specs.precision.ul;
                                    const precisionPass = cvPass || sdPass;
                                    status = (accuracyPass && precisionPass) ? 'PASS' : 'FAIL';
                                }

                                // One row per reading
                                measurements.forEach((reading, idx) => {
                                    csv += `${sessionInfo.calDate},${sessionInfo.technician},${sessionInfo.location},${sessionInfo.client},`;
                                    csv += `${pipette.number},${pipette.brand},${pipette.model},${pipette.serial},${pipette.testVolume},`;
                                    csv += `Single,Reading ${idx + 1},${point.toUpperCase()},${condition === 'asFound' ? 'As Found' : 'As Left'},`;
                                    csv += `${reading},${status},"${pipette.comments || ''}"\n`;
                                });
                            }
                        });
                    });
                } else {
                    // Multi-channel: one reading per channel per test point
                    ['asFound', 'asLeft'].forEach(condition => {
                        for (let ch = 0; ch < pipette.channelCount; ch++) {
                            const lowVal = pipette.measurements[condition].low[ch];
                            const midVal = pipette.measurements[condition].mid[ch];
                            const highVal = pipette.measurements[condition].high[ch];

                            if (lowVal !== '' && midVal !== '' && highVal !== '') {
                                const nominalVolume = getNominalVolume('high', pipette.model);
                                const specs = getSpecifications(pipette.model, nominalVolume, true);

                                let status = 'PENDING';
                                if (specs) {
                                    const allPass = [lowVal, midVal, highVal].every(val =>
                                        val >= specs.accuracy.from && val <= specs.accuracy.to
                                    );
                                    status = allPass ? 'PASS' : 'FAIL';
                                }

                                // One row per test point per channel
                                ['low', 'mid', 'high'].forEach(point => {
                                    const val = pipette.measurements[condition][point][ch];
                                    csv += `${sessionInfo.calDate},${sessionInfo.technician},${sessionInfo.location},${sessionInfo.client},`;
                                    csv += `${pipette.number},${pipette.brand},${pipette.model},${pipette.serial},${pipette.testVolume},`;
                                    csv += `Multi-${pipette.channelCount}ch,Channel ${ch + 1},${point.toUpperCase()},${condition === 'asFound' ? 'As Found' : 'As Left'},`;
                                    csv += `${val},${status},"${pipette.comments || ''}"\n`;
                                });
                            }
                        }
                    });
                }
            });

            // Download CSV
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `calibration_data_${new Date().toISOString().split('T')[0]}.csv`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        // ========== End CSV Export Functions ==========

        // ========== Password Protection ==========
        const CALIBRATION_PASSWORD = 'platinum2024'; // Change this to your desired password

        function checkPassword() {
            // Check if already authenticated in this session
            if (sessionStorage.getItem('calibrationAuth') === 'authenticated') {
                return true;
            }

            // Prompt for password
            const password = prompt('Enter password to access Calibration System:');

            if (password === CALIBRATION_PASSWORD) {
                sessionStorage.setItem('calibrationAuth', 'authenticated');
                return true;
            } else if (password === null) {
                // User clicked cancel
                document.body.innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 100vh; font-family: Arial; font-size: 24px; color: #666;">Access Denied - Password Required</div>';
                return false;
            } else {
                alert('Incorrect password. Access denied.');
                document.body.innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 100vh; font-family: Arial; font-size: 24px; color: #666;">Access Denied - Incorrect Password</div>';
                return false;
            }
        }

        function logout() {
            if (confirm('Logout and clear authentication?')) {
                sessionStorage.removeItem('calibrationAuth');
                location.reload();
            }
        }

        // ========== End Password Protection ==========

        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            // Check password first
            if (!checkPassword()) {
                return; // Stop initialization if password check fails
            }

            // Try to load saved session first
            const sessionLoaded = loadCurrentSession();

            // If no session loaded, set default dates
            if (!sessionLoaded) {
                const today = new Date().toISOString().split('T')[0];
                document.getElementById('calDate').value = today;

                const nextYear = new Date();
                nextYear.setFullYear(nextYear.getFullYear() + 1);
                document.getElementById('dueDate').value = nextYear.toISOString().split('T')[0];

                const firstOfMonth = new Date();
                firstOfMonth.setDate(1);
                document.getElementById('balanceCalDate').value = firstOfMonth.toISOString().split('T')[0];
                document.getElementById('balanceDueDate').value = nextYear.toISOString().split('T')[0];
            }

            loadHistory();

            // Add listeners to session form fields for auto-save
            document.querySelectorAll('#session input, #session select').forEach(input => {
                input.addEventListener('change', debouncedAutoSave);
            });
        });
    </script>

    <div class="container">
        <div class="header">
            <h1>🧪 Advanced Pipette Calibration System</h1>
            <p>ISO 8655 Compliant | Real-time Analysis | Auto-Save Enabled</p>
            <button onclick="logout()" style="position: absolute; top: 20px; right: 20px; padding: 8px 16px; background: #dc3545; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 14px;">🔒 Logout</button>
        </div>

        <div class="nav-tabs">
            <button class="nav-tab active" onclick="showTab('session', this)">📋 Session Info</button>
            <button class="nav-tab" onclick="showTab('calibration', this)">⚖️ Calibration</button>
            <button class="nav-tab" onclick="showTab('analysis', this)">📊 Analysis</button>
            <button class="nav-tab" onclick="showTab('report', this)">📄 Report</button>
            <button class="nav-tab" onclick="showTab('history', this)">📚 History</button>
        </div>

        <!-- Session Info Tab -->
        <div id="session" class="tab-content active">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <h2>📋 Calibration Session Setup</h2>
                <div>
                    <button class="btn btn-success" onclick="newSession()">🆕 New Session</button>
                    <button class="btn btn-primary" onclick="importFromFile()">📥 Import JSON</button>
                </div>
            </div>

            <div class="form-grid">
                <div class="form-group">
                    <label>Service Provider</label>
                    <input type="text" id="serviceProvider" value="Platinum SC Data Intake Worksheets">
                </div>
                <div class="form-group">
                    <label>Location</label>
                    <input type="text" id="location" value="Kansas State University Mosier F103">
                </div>
                <div class="form-group">
                    <label>Address</label>
                    <input type="text" id="address" value="1800 Denison Ave, Manhattan, Ks 66506">
                </div>
                <div class="form-group">
                    <label>Client</label>
                    <input type="text" id="client" value="Janice Muller - Cin Path">
                </div>
                <div class="form-group">
                    <label>Technician</label>
                    <input type="text" id="technician" value="TSD">
                </div>
                <div class="form-group">
                    <label>Calibration Date</label>
                    <input type="date" id="calDate">
                </div>
                <div class="form-group">
                    <label>Due Date</label>
                    <input type="date" id="dueDate">
                </div>
                <div class="form-group">
                    <label>Frequency</label>
                    <select id="frequency">
                        <option value="Annual">Annual</option>
                        <option value="Semi-Annual">Semi-Annual</option>
                        <option value="Quarterly">Quarterly</option>
                        <option value="Monthly">Monthly</option>
                    </select>
                </div>
            </div>

            <div class="environmental-data">
                <h3>🌡️ Environmental Conditions</h3>
                <div class="form-grid">
                    <div class="form-group">
                        <label>Temperature (°C)</label>
                        <input type="number" id="temperature" step="0.1" value="21.8">
                    </div>
                    <div class="form-group">
                        <label>Humidity (%)</label>
                        <input type="number" id="humidity" step="0.1">
                    </div>
                    <div class="form-group">
                        <label>Barometric Pressure (kPa)</label>
                        <input type="number" id="pressure" step="0.1">
                    </div>
                    <div class="form-group">
                        <label>Balance Serial Number</label>
                        <input type="text" id="balanceSerial" value="B621501811">
                    </div>
                    <div class="form-group">
                        <label>Balance Calibration Date</label>
                        <input type="date" id="balanceCalDate">
                    </div>
                    <div class="form-group">
                        <label>Balance Due Date</label>
                        <input type="date" id="balanceDueDate">
                    </div>
                </div>
            </div>

            <button class="btn btn-primary" onclick="showTab('calibration', document.querySelector('.nav-tab:nth-child(2)'))">Next: Start Calibration →</button>
        </div>

        <!-- Calibration Tab -->
        <div id="calibration" class="tab-content">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <h2>⚖️ Pipette Calibration</h2>
                <div>
                    <button class="btn btn-primary" onclick="addPipette()">+ Add Pipette</button>
                    <button class="btn btn-success" onclick="autoFillSampleData()">📊 Load Sample Data</button>
                </div>
            </div>

            <div class="progress-bar">
                <div class="progress-fill" id="progressFill" style="width: 0%"></div>
            </div>

            <div id="pipettesContainer">
                <!-- Pipettes will be added here dynamically -->
            </div>
        </div>

        <!-- Analysis Tab -->
        <div id="analysis" class="tab-content">
            <h2>📊 Real-time Analysis</h2>
            
            <div class="statistics">
                <div class="stat-card">
                    <div class="stat-value" id="totalPipettes">0</div>
                    <div class="stat-label">Total Pipettes</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="passCount">0</div>
                    <div class="stat-label">Passed</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="failCount">0</div>
                    <div class="stat-label">Failed</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="passRate">0%</div>
                    <div class="stat-label">Pass Rate</div>
                </div>
            </div>

            <div id="analysisDetails">
                <!-- Analysis details will be populated here -->
            </div>
        </div>

        <!-- Report Tab -->
        <div id="report" class="tab-content">
            <h2>📄 Calibration Report</h2>

            <div style="margin-bottom: 20px;">
                <button class="btn btn-primary" onclick="generateReport()">📄 Generate Report</button>
                <button class="btn btn-success" onclick="downloadPDF()">📄 Download PDF</button>
                <button class="btn btn-secondary" onclick="printReport()">🖨️ Print</button>
                <br style="margin: 5px 0;">
                <button class="btn btn-success" onclick="exportFormattedCSV()">📊 Export Formatted CSV</button>
                <button class="btn btn-success" onclick="exportDataCSV()">📊 Export Data CSV</button>
                <button class="btn btn-primary" onclick="saveSession()">💾 Save JSON</button>
            </div>

            <div id="reportContent" class="report-section">
                <!-- Report content will be generated here -->
            </div>
        </div>

        <!-- History Tab -->
        <div id="history" class="tab-content">
            <h2>📚 Calibration History</h2>
            
            <div style="margin-bottom: 20px;">
                <button class="btn btn-primary" onclick="loadHistory()">🔄 Refresh History</button>
            </div>

            <div id="historyContainer">
                <!-- History will be populated here -->
            </div>
        </div>
    </div>
</body>
</html>